[{"key": "ConceptualPromptV2_73", "prompt": "Create a Python code to analyze the impact of human activities on nutrient cycling in an ecosystem, given the rates of nutrient inputs, outputs, and internal cycling processes. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to analyze the impact of human activities on nutrient cycling in an ecosystem:\n\n```python\nimport random\n\n# Define rates of nutrient inputs, outputs, and internal cycling processes\nnutrient_input = random.uniform(10.0, 50.0)\nnutrient_output = random.uniform(5.0, 30.0)\ninternal_cycling_rate = random.uniform(0.5, 4.0)\n\n# Function for human activity impact on nutrient input\ndef human_impact_input(activity_rate: float) -> float:\n    return nutrient_input * (1 + activity_rate)\n\n# Function for human activity impact on nutrient output\ndef human_impact_output(activity_rate: float) -> float:\n    return nutrient_output * (1 + activity_rate)\n\n# Function for human activity impact on internal cycling process\ndef human_impact_internal_cycling(activity_rate: float) -> float:\n    return internal_cycling_rate * (1 - activity_rate)\n\n# Calculate the impact of human activities on nutrient cycling\ndef nutrient_cycling_impact(input_rate: float, output_rate: float, cycling_rate: float) -> float:\n    new_input = human_impact_input(input_rate)\n    new_output = human_impact_output(output_rate)\n    new_cycling_rate = human_impact_internal_cycling(cycling_rate)\n    net_nutrient = (new_input - new_output) * new_cycling_rate\n    return net_nutrient\n\n\n# Example human_activity rates\ninput_activity_rate = 0.1\noutput_activity_rate = 0.2\ninternal_cycling_activity_rate = 0.15\n\n# Calculate the impact\nimpact = nutrient_cycling_impact(input_activity_rate, output_activity_rate, internal_cycling_activity_rate)\nprint(\"The impact of human activities on nutrient cycling in the ecosystem is\", impact)\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\n\ndef test_human_impact_input():\n    activity_rate = 0.5\n    assert human_impact_input(activity_rate) == nutrient_input * 1.5\n\ndef test_human_impact_output():\n    activity_rate = 0.5\n    assert human_impact_output(activity_rate) == nutrient_output * 1.5\n\ndef test_human_impact_internal_cycling():\n    activity_rate = 0.5\n    assert human_impact_internal_cycling(activity_rate) == internal_cycling_rate * 0.5\n\ndef test_nutrient_cycling_impact():\n    input_rate = 0.25\n    output_rate = 0.25\n    cycling_rate = 0.25\n    new_input = human_impact_input(input_rate)\n    new_output = human_impact_output(output_rate)\n    new_cycling_rate = human_impact_internal_cycling(cycling_rate)\n    net_nutrient = (new_input - new_output) * new_cycling_rate\n    assert nutrient_cycling_impact(input_rate, output_rate, cycling_rate) == net_nutrient\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\nTo run the tests, save the test code block in a separate file (for example, `test_nutrient_cycling.py`) and run pytest. Remember to include the main code in the same directory or add it to PYTHONPATH."}, {"key": "ConceptualPromptV2_37", "prompt": "Develop a Python program to determine the angular momentum of an object in rotational motion, given its moment of inertia and angular velocity. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python program to calculate the angular momentum of an object in rotational motion:\n\n```python\ndef angular_momentum(moment_of_inertia: float, angular_velocity: float) -> float:\n    \"\"\"\n    Calculate the angular momentum of an object in rotational motion.\n\n    :param moment_of_inertia: The moment of inertia of the object (kg*m^2).\n    :param angular_velocity: The angular velocity of the object (rad/s).\n    :return: The angular momentum of the object (kg*m^2/s).\n    \"\"\"\n    return moment_of_inertia * angular_velocity\n\n\ndef main():\n    # Test data\n    moment_of_inertia = 2.5  # kg*m^2\n    angular_velocity = 7.8  # rad/s\n\n    # Calculate angular momentum\n    result = angular_momentum(moment_of_inertia, angular_velocity)\n    print(f\"Angular momentum: {result:.2f} kg*m^2/s\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nAnd here are the pytest tests to exercise each function:\n\n```python\nimport pytest\nfrom angular_momentum import angular_momentum\n\n\ndef test_angular_momentum():\n    assert angular_momentum(2.0, 5.0) == 10.0\n    assert angular_momentum(1.5, 4.0) == 6.0\n    assert angular_momentum(3.0, 0.0) == 0.0\n    assert round(angular_momentum(2.5, 7.8), 2) == 19.5\n    assert round(angular_momentum(3.8, 6.3), 2) == 23.94\n```"}, {"key": "ConceptualPromptV2_43", "prompt": "Develop a Python function to implement the merge-sort algorithm for sorting a list of numbers. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function implementing the merge-sort algorithm for sorting a list of numbers:\n\n```python\ndef merge_sort(lst):\n    if len(lst) <= 1:      # Base case: a single or empty list is considered sorted\n        return lst\n\n    mid = len(lst) // 2    # Calculate the middle index for splitting the list\n    left = lst[:mid]       # Split the list into two halves\n    right = lst[mid:]\n\n    left = merge_sort(left)     # Recursively sort the left half\n    right = merge_sort(right)   # Recursively sort the right half\n\n    return merge(left, right)   # Merge the two sorted halves\n\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    # Continue merging until either one of the halves is exhausted\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    # Add the remaining elements from the left half\n    while left_index < len(left):\n        merged.append(left[left_index])\n        left_index += 1\n\n    # Add the remaining elements from the right half\n    while right_index < len(right):\n        merged.append(right[right_index])\n        right_index += 1\n\n    return merged\n```\n\nAnd here's a set of pytest tests to exercise the merge_sort function:\n\n```python\nimport pytest\n\nfrom merge_sort import merge_sort\n\n\ndef test_merge_sort_empty_list():\n    assert merge_sort([]) == []\n\n\ndef test_merge_sort_single_element():\n    assert merge_sort([5]) == [5]\n\n\ndef test_merge_sort_sorted_list():\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n\ndef test_merge_sort_unsorted_list():\n    assert merge_sort([4, 2, 1, 5, 3]) == [1, 2, 3, 4, 5]\n\n\ndef test_merge_sort_with_duplicates():\n    assert merge_sort([1, 4, 1, 4, 2]) == [1, 1, 2, 4, 4]\n\n\ndef test_merge_sort_descending_order():\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n```"}, {"key": "ConceptualPromptV2_54", "prompt": "Write a Python program to compute the edit distance between two strings using dynamic programming. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python program to compute the edit distance between two strings using dynamic programming:\n\n```python\ndef edit_distance(s1: str, s2: str) -> int:\n    \"\"\"Compute the edit distance between two strings using dynamic programming.\"\"\"\n    m = len(s1)\n    n = len(s2)\n\n    # Create a table to store the computed edit distances\n    distance_matrix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize the table with distances based on inserting or deleting characters\n    for i in range(m + 1):\n        distance_matrix[i][0] = i\n\n    for j in range(n + 1):\n        distance_matrix[0][j] = j\n\n    # Compute the edit distances using dynamic programming\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                cost = 0\n            else:\n                cost = 1\n\n            distance_matrix[i][j] = min(\n                distance_matrix[i - 1][j] + 1,        # deletion\n                distance_matrix[i][j - 1] + 1,        # insertion\n                distance_matrix[i - 1][j - 1] + cost  # substitution\n            )\n\n    return distance_matrix[m][n]\n\n\nif __name__ == \"__main__\":\n    s1 = \"kitten\"\n    s2 = \"sitting\"\n    print(f\"Edit distance between '{s1}' and '{s2}' is: {edit_distance(s1, s2)}\")\n```\n\nHere are the pytest tests that exercise the edit_distance() function:\n\n```python\nimport pytest\nfrom edit_distance import edit_distance\n\ndef test_edit_distance_case_1():\n    assert edit_distance(\"kitten\", \"sitting\") == 3\n\ndef test_edit_distance_case_2():\n    assert edit_distance(\"abcdef\", \"azced\") == 3\n\ndef test_edit_distance_case_3():\n    assert edit_distance(\"ai\", \"ai\") == 0\n\ndef test_edit_distance_case_4():\n    assert edit_distance(\"abc\", \"\") == 3\n\ndef test_edit_distance_case_5():\n    assert edit_distance(\"\", \"xyz\") == 3\n\ndef test_edit_distance_case_6():\n    assert edit_distance(\"\", \"\") == 0\n\nif __name__ == \"__main__\":\n    pytest.main()\n```"}, {"key": "ConceptualPromptV2_6", "prompt": "Write Python code to implement a logistic regression model for binary classification. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to implement a logistic regression model for binary classification:\n\n```python\nimport numpy as np\n\nclass LogisticRegression:\n    def __init__(self, learning_rate=0.01, num_iterations=1000):\n        self.learning_rate = learning_rate\n        self.num_iterations = num_iterations\n\n    def _sigmoid(self, z):\n        return 1 / (1 + np.exp(-z))\n    \n    def _loss(self, y_true, y_pred):\n        return -np.mean(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))\n\n    def fit(self, X, y):\n        self.weights = np.zeros(X.shape[1])\n        self.bias = 0\n        \n        for _ in range(self.num_iterations):\n            linear_model = np.dot(X, self.weights) + self.bias\n            y_pred = self._sigmoid(linear_model)\n            dw = (1 / X.shape[0]) * np.dot(X.T, (y_pred - y))\n            db = (1 / X.shape[0]) * np.sum(y_pred - y)\n            self.weights -= self.learning_rate * dw\n            self.bias -= self.learning_rate * db\n\n    def predict_proba(self, X):\n        linear_model = np.dot(X, self.weights) + self.bias\n        return self._sigmoid(linear_model)\n\n    def predict(self, X, threshold=0.5):\n        return (self.predict_proba(X) >= threshold).astype(int)\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport numpy as np\nimport pytest\nfrom sklearn.datasets import make_classification\n\n\n@pytest.fixture\ndef synthetic_data():\n    X, y = make_classification(n_samples=100, n_features=2, n_classes=2, n_clusters_per_class=1, random_state=42)\n    return X, y\n\ndef test_sigmoid():\n    lr = LogisticRegression()\n    assert np.isclose(lr._sigmoid(0), 0.5)\n    \ndef test_loss():\n    lr = LogisticRegression()\n    y_true = np.array([1, 0, 1, 0])\n    y_pred = np.array([0.9, 0.1, 0.8, 0.2])\n    assert np.isclose(lr._loss(y_true, y_pred), 0.164252033486018)\n\ndef test_fit_and_predict(synthetic_data):\n    X, y = synthetic_data\n    lr = LogisticRegression(learning_rate=0.1, num_iterations=1000)\n    lr.fit(X, y)\n    y_pred = lr.predict(X)\n    accuracy = np.mean(y_pred == y) * 100\n    assert accuracy >= 90\n```\n\nIn order to run the tests, save the logistic regression implementation and the test suite in separate Python files and use `pytest` to execute them."}, {"key": "ConceptualPromptV2_93", "prompt": "Create a Python code to compute the real GDP growth rate, given the nominal GDP growth rate and the inflation rate. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to compute the real GDP growth rate, given the nominal GDP growth rate and the inflation rate:\n\n```python\ndef real_gdp_growth_rate(nominal_gdp_growth_rate, inflation_rate):\n    \"\"\"\n    Calculate the real GDP growth rate.\n    \n    :param nominal_gdp_growth_rate: Nominal GDP growth rate as a percentage.\n    :param inflation_rate: Inflation rate as a percentage.\n    :return: Real GDP growth rate as a percentage.\n    \"\"\"\n    real_growth_rate = ((1 + nominal_gdp_growth_rate / 100) / (1 + inflation_rate / 100)) - 1\n    return real_growth_rate * 100\n\n# Example values\nnominal_gdp_growth_rate = 5  # 5% nominal GDP growth rate\ninflation_rate = 2  # 2% inflation rate\n\n# Calculate the real GDP growth rate\nreal_growth_rate = real_gdp_growth_rate(nominal_gdp_growth_rate, inflation_rate)\n\n# Output the result\nprint(f\"The real GDP growth rate is {real_growth_rate:.2f}%\")\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom real_gdp_growth import real_gdp_growth_rate\n\ndef test_real_gdp_growth_rate():\n    assert round(real_gdp_growth_rate(5, 2), 2) == 2.94\n    assert round(real_gdp_growth_rate(7, 3), 2) == 3.88\n    assert round(real_gdp_growth_rate(10, 4), 2) == 5.77\n    assert round(real_gdp_growth_rate(0, 0), 2) == 0\n    assert round(real_gdp_growth_rate(-3, 1), 2) == -3.96\n\n```"}, {"key": "ConceptualPromptV2_30", "prompt": "Write a Python program to determine the escape velocity from a celestial body, given its mass and radius. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python program to determine the escape velocity from a celestial body:\n\n```python\nimport math\n\ndef escape_velocity(mass, radius):\n    \"\"\"\n    Calculate the escape velocity from a celestial body, given its mass and radius.\n\n    Args:\n    mass (float): Mass of the celestial body in kg.\n    radius (float): Radius of the celestial body in meters.\n\n    Returns:\n    float: Escape velocity in m/s.\n    \"\"\"\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    return math.sqrt(2 * G * mass / radius)\n\nif __name__ == \"__main__\":\n    mass_earth = 5.972e24  # Earth mass in kg\n    radius_earth = 6.371e6  # Earth radius in meters\n    print(f\"Escape velocity of Earth: {escape_velocity(mass_earth, radius_earth):.2f} m/s\")\n```\n\nAnd here's a set of pytest tests for the provided functions:\n\n```python\nimport pytest\nfrom escape_velocity import escape_velocity\n\ndef test_escape_velocity():\n    mass_earth = 5.972e24\n    radius_earth = 6.371e6\n    result = escape_velocity(mass_earth, radius_earth)\n    assert pytest.approx(result, rel=1e-3) == 11186.25\n\n    mass_mars = 6.4171e23\n    radius_mars = 3.3895e6\n    result = escape_velocity(mass_mars, radius_mars)\n    assert pytest.approx(result, rel=1e-3) == 5027.34\n\n    mass_jupiter = 1.8982e27\n    radius_jupiter = 6.9911e7\n    result = escape_velocity(mass_jupiter, radius_jupiter)\n    assert pytest.approx(result, rel=1e-3) == 59564.97\n```"}, {"key": "ConceptualPromptV2_82", "prompt": "Write a Python program to calculate the present value of a future cash flow, given the discount rate and the number of years until the cash flow is received. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python program to calculate the present value of a future cash flow:\n\n```python\ndef present_value(future_value, discount_rate, years):\n    \"\"\"\n    Calculate the present value of a future cash flow.\n    \n    Parameters:\n    future_value (float): The future cash amount\n    discount_rate (float): The discount rate as a decimal (e.g., 0.05 for 5%)\n    years (float): The number of years until the cash flow is received\n\n    Returns:\n    float: The present value of the future cash flow\n    \"\"\"\n    return future_value / ((1 + discount_rate) ** years)\n\n# Example usage\nfuture_value = 10000  # A future cash flow of 10,000\ndiscount_rate = 0.05  # A discount rate of 5%\nyears = 10  # The cash flow will be received in 10 years\n\npresent_value_result = present_value(future_value, discount_rate, years)\nprint(f\"The present value of the future cash flow is: {present_value_result:.2f}\")\n```\n\nAnd here's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom present_value import present_value\n\ndef test_present_value_positive():\n    assert present_value(10000, 0.05, 10) == pytest.approx(6139.13, rel=1e-2)\n    assert present_value(5000, 0.04, 5) == pytest.approx(4106.92, rel=1e-2)\n\ndef test_present_value_zero():\n    assert present_value(0, 0.05, 10) == 0\n    assert present_value(10000, 0, 10) == 10000\n\ndef test_present_value_negative_rate():\n    with pytest.raises(ValueError):\n        present_value(10000, -0.05, 10)\n\ndef test_present_value_negative_years():\n    with pytest.raises(ValueError):\n        present_value(10000, 0.05, -10)\n```"}, {"key": "ConceptualPromptV2_41", "prompt": "Create a Python function to determine the time complexity of a given algorithm using Big O notation. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "I can provide you with a function for calculating Big O of common algorithms. However, it is important to note that determining the time complexity of an arbitrary algorithm is not possible through code alone. Time complexity depends a lot on the logic of the algorithm, requiring manual analysis to determine the growth of an algorithm in respect to its input size.\n\nBelow is the code for a function that returns the Big O time complexity of some common algorithms:\n\n```python\ndef big_o(algorithm_type, input_size):   \n    \"\"\"\n    Returns the Big O time complexity of some common algorithms.\n    \n    Args:\n    algorithm_type (str): the type of algorithm, such as \"linear\" or \"quadratic\"\n    input_size (int): the size of the input for the algorithm\n    \n    Returns:\n    int: the calculated Big O complexity for the given algorithm type and input size\n    \"\"\"\n\n    if algorithm_type == \"constant\":\n        return 1\n    elif algorithm_type == \"linear\":\n        return input_size\n    elif algorithm_type == \"quadratic\":\n        return input_size ** 2\n    elif algorithm_type == \"cubic\":\n        return input_size ** 3\n    elif algorithm_type == \"logarithmic\":\n        import math\n        return int(math.log2(input_size))\n    elif algorithm_type == \"linearithmic\":\n        import math\n        return input_size * int(math.log2(input_size))\n    else:\n        raise ValueError(\"Unsupported algorithm type\")\n```\n\nHere are pytest tests for each function:\n\n```python\nimport pytest\nfrom big_o_notation import big_o\n\ndef test_big_o_constant():\n    assert big_o(\"constant\", 100) == 1\n\ndef test_big_o_linear():\n    assert big_o(\"linear\", 100) == 100\n\ndef test_big_o_quadratic():\n    assert big_o(\"quadratic\", 100) == 10000\n\ndef test_big_o_cubic():\n    assert big_o(\"cubic\", 10) == 1000\n\ndef test_big_o_logarithmic():\n    assert big_o(\"logarithmic\", 8) == 3\n\ndef test_big_o_linearithmic():\n    assert big_o(\"linearithmic\", 16) == 64\n\ndef test_big_o_unsupported_algorithm():\n    with pytest.raises(ValueError, match=\"Unsupported algorithm type\"):\n        big_o(\"unsupported\", 100)\n```\n\nBefore running the tests, make sure to save the provided function in a file called `big_o_notation.py`, then you can run the tests using the `pytest` command."}, {"key": "ConceptualPromptV2_28", "prompt": "Write Python code to calculate the velocity of an object in circular motion, given the radius and the time period of the motion. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code to calculate the velocity of an object in circular motion, given the radius and the time period of the motion:\n\n```python\nimport math\n\ndef calculate_velocity(radius, time_period):\n    \"\"\"\n    Calculate the velocity of an object in circular motion.\n\n    Args:\n    radius (float): The radius of the circular path (in meters)\n    time_period (float): The time period of one complete revolution (in seconds)\n\n    Returns:\n    float: The velocity of the object (in meters per second)\n    \"\"\"\n    circumference = 2 * math.pi * radius\n    velocity = circumference / time_period\n    return velocity\n\n# Example usage:\nradius = 5.0  # meters\ntime_period = 10.0  # seconds\nvelocity = calculate_velocity(radius, time_period)\nprint(f\"The velocity of the object is {velocity} m/s\")\n```\n\nAnd here is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom circular_motion import calculate_velocity\n\ndef test_calculate_velocity():\n    radius = 5.0\n    time_period = 10.0\n    assert pytest.approx(calculate_velocity(radius, time_period), 3.1416)\n\n    radius = 10.0\n    time_period = 20.0\n    assert pytest.approx(calculate_velocity(radius, time_period), 3.1416)\n\n    radius = 0.0\n    time_period = 1.0\n    assert pytest.approx(calculate_velocity(radius, time_period), 0.0000)\n\n    radius = 5.0\n    time_period = 0.0\n    with pytest.raises(ZeroDivisionError):\n        calculate_velocity(radius, time_period)\n```\n\nBefore running the pytest tests, save the Python code in a file named `circular_motion.py` and the tests in a separate file named `test_circular_motion.py`. Then, to run the tests, simply execute the command `pytest` in the terminal."}, {"key": "ConceptualPromptV2_98", "prompt": "Write a Python program to estimate the interest rate parity, given the spot exchange rate, the forward exchange rate, and the interest rates of the two countries. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python program to estimate the interest rate parity, given the spot exchange rate, the forward exchange rate, and the interest rates of the two countries:\n\n```python\ndef interest_rate_parity(spot_exchange_rate, forward_exchange_rate, interest_rate_1, interest_rate_2):\n    \"\"\"\n    Calculate the interest rate parity based on spot and forward exchange rates and interest rates of two countries.\n\n    :param spot_exchange_rate: The spot exchange rate between the two countries\n    :type spot_exchange_rate: float\n    :param forward_exchange_rate: The forward exchange rate between the two countries\n    :type forward_exchange_rate: float\n    :param interest_rate_1: Interest rate of country 1\n    :type interest_rate_1: float\n    :param interest_rate_2: Interest rate of country 2\n    :type interest_rate_2: float\n    :return: A boolean, True if interest rate parity holds, False otherwise\n    :rtype: bool\n    \"\"\"\n    irp_equation = (1 + interest_rate_1) / (1 + interest_rate_2)\n    exchange_rate_ratio = forward_exchange_rate / spot_exchange_rate\n\n    return round(irp_equation, 6) == round(exchange_rate_ratio, 6)\n\n\n# Example values\nspot_exchange_rate = 1.20\nforward_exchange_rate = 1.22\ninterest_rate_1 = 0.05\ninterest_rate_2 = 0.03\n\n# Check if interest rate parity holds\nresult = interest_rate_parity(spot_exchange_rate, forward_exchange_rate, interest_rate_1, interest_rate_2)\nprint(result)\n```\n\nNow, here is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom parity import interest_rate_parity\n\n@pytest.mark.parametrize(\"spot_exchange_rate, forward_exchange_rate, interest_rate_1, interest_rate_2, expected\", [\n    (1.20, 1.22, 0.05, 0.03, True),\n    (1.50, 1.80, 0.02, 0.01, False),\n    (2.00, 2.10, 0.03, 0.05, True),\n    (1.10, 1.20, 0.06, 0.08, False),\n])\ndef test_interest_rate_parity(spot_exchange_rate, forward_exchange_rate, interest_rate_1, interest_rate_2, expected):\n    result = interest_rate_parity(spot_exchange_rate, forward_exchange_rate, interest_rate_1, interest_rate_2)\n    assert result == expected\n```\n\nYou can run the tests using `pytest` in the command line within the same directory as the test file."}, {"key": "ConceptualPromptV2_7", "prompt": "Generate Python code to calculate the root-mean-square error (RMSE) between predicted and actual values. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to calculate the root-mean-square error (RMSE) between predicted and actual values:\n\n```python\nimport numpy as np\n\ndef calculate_rmse(predicted_values, actual_values):\n    \"\"\"\n    Calculate the Root Mean Square Error (RMSE) between the predicted and actual values.\n\n    Args:\n    predicted_values (list,1d-array): List or 1D array containing the predicted values.\n    actual_values (list, 1d-array): List or 1D array containing the actual values.\n\n    Returns:\n    float: The root mean square error (RMSE) value.\n    \"\"\"\n    if len(predicted_values) != len(actual_values):\n        raise ValueError(\"Both predicted and actual values must have same length\")\n\n    squared_errors = [(pred - actual)**2 for pred, actual in zip(predicted_values, actual_values)]\n    mean_squared_error = np.mean(squared_errors)\n    rmse = np.sqrt(mean_squared_error)\n    return rmse\n\n# Example usage:\npredicted = np.array([3.1, 5.0, 7.5, 9.7, 10.5])\nactual = np.array([3, 5, 8, 10, 11])\nrmse_value = calculate_rmse(predicted, actual)\nprint(\"RMSE:\", rmse_value)\n```\n\nHere's a pytest test suite for the `calculate_rmse` function:\n\n```python\nimport pytest\nfrom your_module import calculate_rmse\n\n@pytest.mark.parametrize(\"predicted,actual,expected_rmse\", [\n    ([3, 5, 8, 10, 11], [3, 5, 8, 10, 11], 0),\n    ([-3, -5, -8, -10, -11], [-3, -5, -8, -10, -11], 0),\n    ([0, 0, 0, 0, 0], [1, 1, 1, 1, 1], 1),\n    ([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 1),\n])\ndef test_calculate_rmse(predicted, actual, expected_rmse):\n    assert calculate_rmse(predicted, actual) == pytest.approx(expected_rmse, abs=1e-6)\n\n@pytest.mark.parametrize(\"predicted,actual\", [\n    ([], [1, 2, 3]),\n    ([1], [1, 2, 3]),\n    ([1, 2, 3], []),\n])\ndef test_calculate_rmse_value_error(predicted, actual):\n    with pytest.raises(ValueError):\n        calculate_rmse(predicted, actual)\n```\n\nRemember to replace `your_module` with the actual name of the module containing the `calculate_rmse` function in the import statement in the test suite."}, {"key": "ConceptualPromptV2_20", "prompt": "Write Python code to calculate the gravitational force between two objects using their masses and the distance between them. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to calculate the gravitational force between two objects using their masses and the distance between them:\n\n```python\nimport math\n\ndef gravitational_force(m1, m2, r):\n    \"\"\"\n    Calculate the gravitational force between two objects.\n    \n    Parameters:\n    m1 (float): Mass of first object in kilograms\n    m2 (float): Mass of second object in kilograms\n    r (float): Distance between the two objects in meters\n\n    Returns:\n    float: Gravitational force between the two objects in Newtons\n    \"\"\"\n    G = 6.67430e-11  # Universal gravitational constant in m^3 kg^-1 s^-2\n    force = G * m1 * m2 / (r ** 2)\n    return force\n\nif __name__ == \"__main__\":\n    mass_earth = 5.972e24  # Mass of Earth in kg\n    mass_moon = 7.342e22  # Mass of Moon in kg\n    distance_earth_moon = 384400000  # Distance between Earth and Moon in m\n\n    force = gravitational_force(mass_earth, mass_moon, distance_earth_moon)\n    print(f\"Gravitational force between Earth and Moon: {force} N\")\n```\n\nHere's the pytest test suite for the given code:\n\n```python\nimport pytest\nfrom gravitational_force import gravitational_force\n\ndef test_gravitational_force():\n    mass_earth = 5.972e24\n    mass_moon = 7.342e22\n    distance_earth_moon = 384400000\n    expected_force = 1.982e20\n\n    # Test the function with Earth and Moon examples\n    result = gravitational_force(mass_earth, mass_moon, distance_earth_moon)\n    assert pytest.approx(result) == expected_force\n\n    # Test the function with equal masses and distance\n    m1 = m2 = 1e3\n    r = 10\n    expected_force = 6.67430e-11\n\n    result = gravitational_force(m1, m2, r)\n    assert pytest.approx(result) == expected_force\n\n    # Test the function with zero masses\n    m1 = 0\n    m2 = 5e3\n    r = 100\n    expected_force = 0\n\n    result = gravitational_force(m1, m2, r)\n    assert pytest.approx(result) == expected_force\n```"}, {"key": "ConceptualPromptV2_21", "prompt": "Create a Python function to calculate the projectile motion of an object, given its initial velocity, launch angle, and the acceleration due to gravity. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code for calculating the projectile motion of an object:\n\n```python\nimport math\n\ndef projectile_motion(initial_velocity, launch_angle, gravity=-9.81):\n    \"\"\"\n    Calculate the motion of a projectile given the initial velocity,\n    launch angle, and acceleration due to gravity.\n\n    Args:\n    initial_velocity (float): Initial velocity of the projectile (m/s).\n    launch_angle (float): Launch angle of the projectile in degrees.\n    gravity (float, optional): Acceleration due to gravity (m/s^2). Default value is -9.81.\n\n    Returns:\n    tuple: Contains maximum height (m), time of flight (s), and horizontal range (m).\n    \"\"\"\n\n    # Convert launch angle to radians\n    angle_radians = math.radians(launch_angle)\n\n    # Calculate time of flight\n    time_of_flight = (2 * initial_velocity * math.sin(angle_radians)) / gravity\n\n    # Calculate maximum height\n    max_height = (initial_velocity**2 * math.sin(angle_radians)**2) / (2 * -gravity)\n\n    # Calculate horizontal range\n    horizontal_range = initial_velocity * time_of_flight * math.cos(angle_radians)\n\n    return max_height, time_of_flight, horizontal_range\n\n# Test example\ninitial_velocity = 20  # m/s\nlaunch_angle = 45  # degrees\n\nmax_height, time_of_flight, horizontal_range = projectile_motion(initial_velocity, launch_angle)\nprint(\"Max Height:\", max_height)\nprint(\"Time of Flight:\", time_of_flight)\nprint(\"Horizontal Range:\", horizontal_range)\n```\n\nNow, here's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom projectile_motion import projectile_motion\n\ndef test_projectile_motion_max_height():\n    max_height, _, _ = projectile_motion(20, 45)\n    assert round(max_height, 2) == 10.20\n\ndef test_projectile_motion_time_of_flight():\n    _, time_of_flight, _ = projectile_motion(20, 45)\n    assert round(time_of_flight, 2) == 2.04\n\ndef test_projectile_motion_horizontal_range():\n    _, _, horizontal_range = projectile_motion(20, 45)\n    assert round(horizontal_range, 2) == 40.41\n\ndef test_projectile_motion_invalid_launch_angle():\n    with pytest.raises(ValueError):\n        projectile_motion(20, -20)\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\nRemember to save the projectile motion function in a separate file named `projectile_motion.py`."}, {"key": "ConceptualPromptV2_5", "prompt": "Create Python code to perform a Chi-squared test of independence for categorical variables. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code for the Chi-squared test of independence:\n\n```python\nimport numpy as np\nimport scipy.stats as stats\n\ndef create_contingency_table(a, b):\n    \"\"\"\n    Create a contingency table given two categorical variables.\n\n    :param a: A list of categories for the first variable\n    :param b: A list of categories for the second variable\n    :return: A numpy array representing the contingency table\n    \"\"\"\n    a_categories = list(set(a))\n    b_categories = list(set(b))\n    table = np.zeros((len(a_categories), len(b_categories)))\n\n    for i, a_categ in enumerate(a_categories):\n        for j, b_categ in enumerate(b_categories):\n            table[i][j] = sum((a == a_categ) & (b == b_categ))\n\n    return table\n\n\ndef chi_squared_test(table):\n    \"\"\"\n    Perform the chi-squared test on a contingency table.\n\n    :param table: A numpy array representing the contingency table\n    :return: The test statistic, p-value, degrees of freedom, and expected frequencies\n    \"\"\"\n    return stats.chi2_contingency(table)\n\n\ndef main():\n    # Sample data\n    a_categories = [\"A\", \"A\", \"B\", \"B\", \"A\", \"B\", \"A\", \"B\", \"A\", \"B\"]\n    b_categories = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"X\", \"Y\", \"Y\", \"X\", \"Y\"]\n\n    table = create_contingency_table(a_categories, b_categories)\n\n    chi2, p, df, expected = chi_squared_test(table)\n\n    print(\"Chi-Square Statistic:\", chi2)\n    print(\"P-Value:\", p)\n    print(\"Degrees of Freedom:\", df)\n    print(\"Expected Frequencies:\", expected)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nHere is the pytest code to test the functions:\n\n```python\nimport pytest\nimport numpy as np\nfrom chi_squared_test import create_contingency_table, chi_squared_test\n\ndef test_create_contingency_table():\n    a = [\"A\", \"A\", \"B\", \"B\", \"A\", \"B\", \"A\", \"B\", \"A\", \"B\"]\n    b = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"X\", \"Y\", \"Y\", \"X\", \"Y\"]\n\n    expected_table = np.array([[3.0, 2.0], [2.0, 3.0]])\n    assert np.array_equal(create_contingency_table(a, b), expected_table)\n\ndef test_chi_squared_test():\n    table = np.array([[3.0, 2.0], [2.0, 3.0]])\n    \n    chi2, p, df, expected = chi_squared_test(table)\n    \n    assert pytest.approx(chi2, 0.2)\n    assert pytest.approx(p, 0.6543, rel=1e-3)\n    assert df == 1\n    assert np.allclose(expected, np.array([[2.5, 2.5], [2.5, 2.5]]))\n\nif __name__ == \"__main__\":\n    pytest.main()\n```"}, {"key": "ConceptualPromptV2_95", "prompt": "Develop a Python function to model the Solow growth model, given the savings rate, depreciation rate, population growth rate, and the production function. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python function to model the Solow growth model:\n\n```python\nimport numpy as np\n\ndef solow_growth_model(S, delta, n, f, K0, L0, T):\n    \"\"\"\n    Solow Growth Model function.\n\n    Parameters:\n    - S (float): savings rate\n    - delta (float): depreciation rate\n    - n (float): population growth rate\n    - f (function): production function (takes K and L as input, returns Y)\n    - K0 (float): initial capital stock\n    - L0 (float): initial labor force\n    - T (int): time periods\n\n    Returns:\n    - K_path (list): path of capital over time\n    - L_path (list): path of labor over time\n    \"\"\"\n\n    # Initialize paths\n    K_path = [K0]\n    L_path = [L0]\n\n    # Iterate for T periods\n    for t in range(1, T + 1):\n        Yt = f(K_path[-1], L_path[-1])\n        It = S * Yt\n        Kt_next = (1 - delta) * K_path[-1] + It\n        Lt_next = L_path[-1] * (1 + n)\n\n        K_path.append(Kt_next)\n        L_path.append(Lt_next)\n\n    return K_path, L_path\n\n# Cobb-Douglas production function\ndef cobb_douglas(K, L, A=1, alpha=0.3, beta=0.7):\n    return A * (K ** alpha) * (L ** beta)\n\n# Example usage\nS = 0.25\ndelta = 0.05\nn = 0.01\nK0 = 1000\nL0 = 1000\nT = 10\n\nK_path, L_path = solow_growth_model(S, delta, n, lambda K, L: cobb_douglas(K, L), K0, L0, T)\nprint(\"Capital path:\", K_path)\nprint(\"Labor path:\", L_path)\n```\n\nAnd here is the set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom solow_growth import solow_growth_model, cobb_douglas\n\ndef test_cobb_douglas():\n    K = 1000\n    L = 1000\n    A = 1\n    alpha = 0.3\n    beta = 0.7\n\n    assert np.isclose(cobb_douglas(K, L, A, alpha, beta), 1000)\n\ndef test_solow_growth_model():\n    S = 0.25\n    delta = 0.05\n    n = 0.01\n    K0 = 1000\n    L0 = 1000\n    T = 10\n\n    K_path, L_path = solow_growth_model(S, delta, n, lambda K, L: cobb_douglas(K, L), K0, L0, T)\n\n    assert len(K_path) == T + 1\n    assert len(L_path) == T + 1\n    assert K_path[0] == K0\n    assert L_path[0] == L0\n\n    # Test for increasing labor force\n    for i in range(T):\n        assert L_path[i + 1] > L_path[i]\n\n    # Test for positive capital growth in the first period\n    assert K_path[1] > K_path[0]\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\n\nYou can run the tests by executing `pytest your_test_file.py` after saving them in `your_test_file.py`."}, {"key": "ConceptualPromptV2_18", "prompt": "Create Python code to calculate the F1-score for a binary classification problem. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to calculate the F1-score for a binary classification problem:\n\n```python\nfrom sklearn.metrics import f1_score, precision_score, recall_score\n\ndef calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1-score for a binary classification problem\n    Args:\n    y_true: list of true labels (binary values)\n    y_pred: list of predicted labels (binary values)\n\n    Returns:\n    f1: float, F1-score\n    \"\"\"\n    f1 = f1_score(y_true, y_pred)\n    return f1\n\ndef main():\n    # Example true and predicted labels for a binary classification problem\n    y_true = [0, 0, 1, 1, 1, 1, 0, 1, 1, 0]\n    y_pred = [0, 1, 1, 1, 0, 1, 0, 1, 0, 0]\n\n    f1 = calculate_f1_score(y_true, y_pred)\n\n    print(\"F1-score: {:.2f}\".format(f1))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nHere's a set of pytest tests to exercise each of the functions:\n\n```python\nimport pytest\nfrom f1_score import calculate_f1_score\n\ndef test_calculate_f1_score():\n    y_true = [0, 0, 1, 1, 1, 1, 0, 1, 1, 0]\n    y_pred = [0, 1, 1, 1, 0, 1, 0, 1, 0, 0]\n    expected_f1 = 0.7272727272727273\n\n    f1 = calculate_f1_score(y_true, y_pred)\n    assert f1 == pytest.approx(expected_f1)\n```\nMake sure to save the first code block in a file named `f1_score.py` and the second code block in a file named `test_f1_score.py`. To run the tests, you need to have `pytest` installed in your Python environment. Install it using `pip install pytest` if you haven't already, and then simply run `pytest` in the terminal."}, {"key": "ConceptualPromptV2_71", "prompt": "Develop a Python code to model the effects of climate change on species distributions, given the species' temperature and precipitation tolerances, and the projected climate scenarios. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "First, let's create a Python script to model the effects of climate change on species distributions based on species' temperature and precipitation tolerances, and projected climate scenarios. I will use the numpy and random libraries to create synthetic data and manipulate arrays.\n\n```python\nimport numpy as np\nimport random\n\n# Define species' temperature and precipitation tolerances\nspecies_tolerances = {\n    'species_1': {'temp': (5, 30), 'precip': (800, 1200)},\n    'species_2': {'temp': (10, 25), 'precip': (500, 1000)},\n    'species_3': {'temp': (0, 15), 'precip': (600, 1400)}\n}\n\n# Projected climate scenarios\nprojected_climate_data = [\n    {'year': 2021, 'temp': 12, 'precip': 850},\n    {'year': 2022, 'temp': 13, 'precip': 870},\n    {'year': 2023, 'temp': 14, 'precip': 880},\n    {'year': 2024, 'temp': 15, 'precip': 930}\n]\n\n\ndef generate_species_distribution(species_name, climate_data):\n    tolerance = species_tolerances[species_name]\n\n    distribution_matrix = np.zeros((len(climate_data), 2))\n    \n    for i, year_data in enumerate(climate_data):\n        suitable_temp = tolerance['temp'][0] <= year_data['temp'] <= tolerance['temp'][1]\n        suitable_precip = tolerance['precip'][0] <= year_data['precip'] <= tolerance['precip'][1]\n        suitable = suitable_temp and suitable_precip\n\n        if suitable:\n            distribution_matrix[i] = [year_data['year'], 1]\n        else:\n            distribution_matrix[i] = [year_data['year'], 0]\n\n    return distribution_matrix\n\n\ndef print_species_distribution_matrix(species_list, reference_data):\n    for species in species_list:\n        print(f\"Climate suitability for {species}:\")\n        matrix = generate_species_distribution(species, reference_data)\n        print(matrix)\n        print(\"\\n\")\n\n\nprint_species_distribution_matrix(species_tolerances.keys(), projected_climate_data)\n```\n\nNext, let's create a set of pytest tests that exercise each of the functions in the script.\n\n```python\nimport pytest\nimport numpy as np\nfrom climate_model import species_tolerances, projected_climate_data, generate_species_distribution\n\ndef test_generate_species_distribution():\n    test_distribution = generate_species_distribution('species_1', projected_climate_data)\n    expected_distribution = np.array([\n        [2021, 1],\n        [2022, 1],\n        [2023, 1],\n        [2024, 1]\n    ])\n\n    assert np.array_equal(test_distribution, expected_distribution)\n\n@pytest.mark.parametrize(\"species_name,expected_tolerance\", [\n    ('species_1', {'temp': (5, 30), 'precip': (800, 1200)}),\n    ('species_2', {'temp': (10, 25), 'precip': (500, 1000)}),\n    ('species_3', {'temp': (0, 15), 'precip': (600, 1400)})\n])\ndef test_species_tolerances(species_name, expected_tolerance):\n    assert species_tolerances[species_name] == expected_tolerance\n\ndef test_projected_climate_data():\n    years = [2021, 2022, 2023, 2024]\n    for i, year_data in enumerate(projected_climate_data):\n        assert year_data['year'] == years[i]\n        assert \"temp\" in year_data\n        assert \"precip\" in year_data\n```\n\nYou should save the two code blocks to respective files, such as `climate_model.py` and `test_climate_model.py`. Then, you can run `pytest test_climate_model.py` to test the climate model code."}, {"key": "ConceptualPromptV2_72", "prompt": "Write a Python function to calculate the ecological niche overlap between two species, given their resource utilization curves. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to calculate the ecological niche overlap between two species given their resource utilization curves:\n\n```python\nimport numpy as np\n\ndef create_resource_utilization_curve(num_resources, min_value=0, max_value=1):\n    \"\"\"\n    Generate a random resource utilization curve.\n    \n    Params:\n    -------\n    num_resources: int\n        Number of resources to be allocated\n    min_value: float, optional (default: 0)\n        Minimum value for resource allocation\n    max_value: float, optional (default: 1)\n        Maximum value for resource allocation\n        \n    Returns:\n    --------\n    np.array\n        Array with resource allocations normalized to sum to 1\n    \"\"\"\n    resources = np.random.uniform(min_value, max_value, num_resources)\n    resources /= np.sum(resources)\n    return resources\n\ndef calculate_ecological_niche_overlap(species1_resources, species2_resources):\n    \"\"\"\n    Calculate the ecological niche overlap between two species.\n    \n    Params:\n    -------\n    species1_resources: np.array\n        Array containing the resource utilization curve for species 1\n    species2_resources: np.array\n        Array containing the resource utilization curve for species 2\n        \n    Returns:\n    --------\n    float\n        Ecological niche overlap value (ranges from 0 to 1)\n    \"\"\"\n    if len(species1_resources) != len(species2_resources):\n        raise ValueError(\"Resource utilization curves should have the same length\")\n    return np.sum(np.minimum(species1_resources, species2_resources))\n\n# Example usage\nspecies1_resources = create_resource_utilization_curve(10)\nspecies2_resources = create_resource_utilization_curve(10)\noverlap = calculate_ecological_niche_overlap(species1_resources, species2_resources)\nprint(\"Ecological niche overlap:\", overlap)\n```\n\nHere's a set of pytest tests that exercise the functions:\n\n```python\nimport pytest\nimport numpy as np\n\ndef test_create_resource_utilization_curve():\n    curve = create_resource_utilization_curve(5)\n    assert len(curve) == 5\n    assert np.isclose(np.sum(curve), 1)\n    assert np.all(curve >= 0) and np.all(curve <= 1)\n\ndef test_calculate_ecological_niche_overlap():\n    curve1 = np.array([0.1, 0.2, 0.3, 0.4])\n    curve2 = np.array([0.4, 0.3, 0.2, 0.1])\n    overlap = calculate_ecological_niche_overlap(curve1, curve2)\n    assert np.isclose(overlap, 0.4)\n\n    curve3 = np.array([1, 0, 0, 0])\n    curve4 = np.array([0, 0, 0, 1])\n    overlap = calculate_ecological_niche_overlap(curve3, curve4)\n    assert np.isclose(overlap, 0)\n\n    curve5 = np.array([0.1, 0.2, 0.3, 0.4])\n    curve6 = np.array([0.1, 0.2, 0.3])\n    with pytest.raises(ValueError):\n        overlap = calculate_ecological_niche_overlap(curve5, curve6)\n\n```"}, {"key": "ConceptualPromptV2_75", "prompt": "Develop a Python function to calculate the resilience of an ecosystem, given its recovery rates and disturbance frequency. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "I will first write a Python function to calculate the resilience of an ecosystem. The resilience of an ecosystem can be calculated using the formula:\n\n`resilience = recovery_rate / (recovery_rate + disturbance_frequency)`\n\nwhere `recovery_rate` and `disturbance_frequency` are positive values.\n\nHere's the code for the function:\n\n```python\ndef ecosystem_resilience(recovery_rate, disturbance_frequency):\n    \"\"\"\n    Calculate the resilience of an ecosystem.\n\n    Args:\n        recovery_rate (float): The recovery rate of the ecosystem.\n        disturbance_frequency (float): The disturbance frequency in the ecosystem.\n\n    Returns:\n        float: The calculated resilience of the ecosystem.\n    \"\"\"\n    if recovery_rate < 0 or disturbance_frequency < 0:\n        raise ValueError(\"Recovery rate and disturbance frequency must be positive values.\")\n    \n    resilience = recovery_rate / (recovery_rate + disturbance_frequency)\n    \n    return resilience\n```\n\nNow, let's generate a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom ecosystem_resilience import ecosystem_resilience\n\ndef test_ecosystem_resilience_normal_conditions():\n    assert ecosystem_resilience(2, 1) == 2 / (2 + 1)\n    assert ecosystem_resilience(3, 3) == 3 / (3 + 3)\n    assert ecosystem_resilience(5, 3) == 5 / (5 + 3)\n\ndef test_ecosystem_resilience_zero_values():\n    assert ecosystem_resilience(0, 1) == 0\n    assert ecosystem_resilience(1, 0) == 1\n\ndef test_ecosystem_resilience_negative_values():\n    with pytest.raises(ValueError):\n        ecosystem_resilience(-2, 1)\n    with pytest.raises(ValueError):\n        ecosystem_resilience(1, -1)\n    with pytest.raises(ValueError):\n        ecosystem_resilience(-2, -1)\n```\n\nSave the first code block in a file named `ecosystem_resilience.py`, and the second code block in a file named `test_ecosystem_resilience.py`. To run the tests, make sure you have pytest installed (`pip install pytest`) and execute `pytest test_ecosystem_resilience.py`."}, {"key": "ConceptualPromptV2_55", "prompt": "Develop a Python code to implement the Bellman-Ford algorithm for finding the shortest path in a weighted graph with negative weights. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the Bellman-Ford algorithm:\n\n```python\n# Bellman-Ford Algorithm for finding single-source shortest paths\n# in a weighted graph with negative weights.\n\ndef initialize(graph, source):\n    \"\"\"\n    Initialize distance and predecessor dictionaries for the graph.\n    \"\"\"\n    distance, predecessor = {}, {}\n    for node in graph:\n        # Set initial distances to infinity for all nodes except the source.\n        distance[node] = float('inf')\n        predecessor[node] = None\n    distance[source] = 0\n    return distance, predecessor\n\n\ndef bellman_ford(graph, source):\n    \"\"\"\n    Finds the shortest path in a weighted graph with negative weights.\n    \"\"\"\n    distance, predecessor = initialize(graph, source)\n\n    # Relax the edges |V| - 1 times.\n    for _ in range(len(graph) - 1):\n        for u in graph:\n            for v, weight in graph[u]:\n                new_distance = distance[u] + weight\n                if new_distance < distance[v]:\n                    distance[v] = new_distance\n                    predecessor[v] = u\n\n    # Check for negative cycles.\n    for u in graph:\n        for v, weight in graph[u]:\n            if distance[u] + weight < distance[v]:\n                raise ValueError(\"Graph contains a negative-weight cycle\")\n\n    return distance, predecessor\n\n\ndef main():\n    # Create a sample weighted graph represented by an adjacency list.\n    graph = {\n        'a': [('b', -1), ('c', 4)],\n        'b': [('c', 3), ('d', 2), ('e', 2)],\n        'c': [],\n        'd': [('b', 1), ('c', 5)],\n        'e': [('d', -3)],\n    }\n\n    # Find the single-source shortest paths using Bellman-Ford algorithm.\n    distance, predecessor = bellman_ford(graph, 'a')\n\n    # Print shortest distance from the source (a) to all other nodes.\n    print(\"Shortest distances from the source:\", distance)\n\n    # Print the predecessor of each node on the shortest path.\n    print(\"Predecessor nodes in the shortest path:\", predecessor)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow, for the pytest tests:\n\n```python\nimport pytest\nfrom bellman_ford import initialize, bellman_ford\n\ndef test_initialize():\n    graph = {'a': [('b', 1)], 'b': [('a', 1)]}\n    distance, predecessor = initialize(graph, 'a')\n    assert distance == {'a': 0, 'b': float('inf')}\n    assert predecessor == {'a': None, 'b': None}\n\ndef test_bellman_ford_no_negative_weights():\n    graph = {\n        'a': [('b', 2), ('c', 7)],\n        'b': [('c', 3), ('d', 4)],\n        'c': [('d', 1)],\n        'd': [],\n    }\n    distance, predecessor = bellman_ford(graph, 'a')\n    assert distance == {'a': 0, 'b': 2, 'c': 5, 'd': 6}\n    assert predecessor == {'a': None, 'b': 'a', 'c': 'b', 'd': 'c'}\n\ndef test_bellman_ford_negative_weights():\n    graph = {\n        'a': [('b', -1), ('c', 4)],\n        'b': [('c', 3), ('d', 2), ('e', 2)],\n        'c': [],\n        'd': [('b', 1), ('c', 5)],\n        'e': [('d', -3)],\n    }\n    distance, predecessor = bellman_ford(graph, 'a')\n    assert distance == {'a': 0, 'b': -1, 'c': 2, 'd': -2, 'e': 1}\n    assert predecessor == {'a': None, 'b': 'a', 'c': 'b', 'd': 'e', 'e': 'b'}\n\ndef test_bellman_ford_negative_cycles():\n    graph = {\n        'a': [('b', -1), ('c', 4)],\n        'b': [('c', 3), ('d', 2), ('e', 2)],\n        'c': [],\n        'd': [('b', 1), ('c', 5)],\n        'e': [('d', -5)],\n    }\n    with pytest.raises(ValueError, match=\"Graph contains a negative-weight cycle\"):\n        _ = bellman_ford(graph, 'a')\n```\n\nMake sure to save the Bellman-Ford implementation in a separate file named `bellman_ford.py` and the tests in another file named `test_bellman_ford.py`. Then run the tests using:\n\n```\npytest test_bellman_ford.py\n```"}, {"key": "ConceptualPromptV2_63", "prompt": "Develop a Python code to calculate the biodiversity index of an ecosystem using the Simpson's Diversity Index, given the number of species and their relative abundances. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code for calculating the biodiversity index using the Simpson's Diversity Index:\n\n```python\ndef calculate_simpsons_diversity_index(species_counts):\n    \"\"\"\n    Calculate the Simpson's Diversity Index based on the species counts in an ecosystem.\n    \n    :param species_counts: a list of counts of different species in the ecosystem\n    :return: the Simpson's Diversity Index (D) as a float\n    \"\"\"\n    total_count = sum(species_counts)\n    sum_of_squares = sum([count ** 2 for count in species_counts])\n    diversity_index = 1 - sum_of_squares / (total_count ** 2)\n\n    return diversity_index\n\n\ndef main():\n    # Example species counts in an ecosystem\n    example_counts = [45, 22, 16, 9, 8]\n    biodiversity_index = calculate_simpsons_diversity_index(example_counts)\n    print(\"The biodiversity index of the given ecosystem is:\", biodiversity_index)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nHere is a separate code block with pytest tests for the `calculate_simpsons_diversity_index` function:\n\n```python\nimport pytest\nfrom biodiversity import calculate_simpsons_diversity_index\n\n\ndef test_calculate_simpsons_diversity_index():\n    test_data = [\n        ([45, 22, 16, 9, 8], 0.7386978417266187),\n        ([1, 1, 1, 1, 1], 0.8),\n        ([100, 0, 0], 0.98),\n        ([1], 0),\n        ([50, 50], 0.5),\n    ]\n\n    for counts, expected_diversity_index in test_data:\n        result = calculate_simpsons_diversity_index(counts)\n        assert pytest.approx(result) == expected_diversity_index\n```\n\nTo run the tests, save the Python code with the function in a file named `biodiversity.py`, and the tests in a file named `test_biodiversity.py`. Then, run `pytest` in the terminal."}, {"key": "ConceptualPromptV2_96", "prompt": "Write a Python code to calculate the marginal propensity to consume (MPC), given the change in consumption and the change in disposable income. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code to calculate the Marginal Propensity to Consume (MPC):\n\n```python\ndef calculate_mpc(change_in_consumption, change_in_disposable_income):\n    \"\"\"\n    Calculates the Marginal Propensity to Consume (MPC) using the formula:\n    MPC = Change in Consumption (\u0394C) / Change in Disposable Income (\u0394Y)\n\n    Args:\n    change_in_consumption (float): Change in consumption.\n    change_in_disposable_income (float): Change in disposable income.\n\n    Returns:\n    float: Returns the Marginal Propensity to Consume.\n    \"\"\"\n    if change_in_disposable_income == 0:\n        raise ValueError(\"Change in disposable income cannot be 0\")\n\n    mpc = change_in_consumption / change_in_disposable_income\n    return mpc\n\n\nif __name__ == \"__main__\":\n    # Example values\n    change_in_consumption = 50\n    change_in_disposable_income = 100\n\n    mpc = calculate_mpc(change_in_consumption, change_in_disposable_income)\n    print(f\"The Marginal Propensity to Consume is: {mpc}\")\n```\n\nThe following code block contains the `pytest` tests:\n\n```python\nimport pytest\nfrom mpc_calculator import calculate_mpc\n\ndef test_calculate_mpc_normal_case():\n    assert calculate_mpc(100, 200) == 0.5\n    assert calculate_mpc(-50, -100) == 0.5\n    assert calculate_mpc(40, 80) == 0.5\n\ndef test_calculate_mpc_zero_disposable_income():\n    with pytest.raises(ValueError):\n        assert calculate_mpc(100, 0)\n\ndef test_calculate_mpc_negative_mpc():\n    assert calculate_mpc(-25, 50) == -0.5\n    assert calculate_mpc(25, -50) == -0.5\n```\n\nBefore running the tests, ensure that you have `pytest` installed (`pip install pytest`). Then, save the MPC calculation code in a Python file (e.g., `mpc_calculator.py`) and the tests in another Python file (e.g., `test_mpc_calculator.py`). Finally, use the command `pytest test_mpc_calculator.py` to execute the tests."}, {"key": "ConceptualPromptV2_27", "prompt": "Develop a Python function to compute the energy levels of a hydrogen atom using the Rydberg formula. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function that computes the energy levels of a hydrogen atom using the Rydberg formula:\n\n```python\nimport math\n\ndef rydberg_constant():\n    \"\"\"\n    Returns the Rydberg constant for hydrogen in joules.\n    \"\"\"\n    return 2.179e-18\n\ndef energy_level(n1, n2):\n    \"\"\"\n    Returns the energy difference between two energy levels of a hydrogen atom, n1 and n2, in joules.\n    Parameters:\n    - n1 (int): The principal quantum number for the first energy level, must be a positive integer.\n    - n2 (int): The principal quantum number for the second energy level, must be a positive integer.\n    \"\"\"\n    if not (isinstance(n1, int) and isinstance(n2, int)):\n        raise ValueError(\"n1 and n2 must be integers\")\n    if n1 <= 0 or n2 <= 0:\n        raise ValueError(\"n1 and n2 must be positive integers\")\n    \n    R = rydberg_constant()\n    energy_diff = R * (1 / (n1 * n1) - 1 / (n2 * n2))\n    return energy_diff\n```\n\nAnd here's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom hydrogen_energy import rydberg_constant, energy_level\n\ndef test_rydberg_constant():\n    assert math.isclose(rydberg_constant(), 2.179e-18, rel_tol=1e-9), \"Rydberg constant for hydrogen is incorrect\"\n\ndef test_energy_level():\n    # Test some known energy level differences\n    assert math.isclose(energy_level(1, 2), 1.635e-19, rel_tol=1e-9), \"Energy difference for n1=1, n2=2 is incorrect\"\n    assert math.isclose(energy_level(2, 3), 1.922e-20, rel_tol=1e-9), \"Energy difference for n1=2, n2=3 is incorrect\"\n    \n    # Test invalid input cases\n    with pytest.raises(ValueError):\n        energy_level(0, 2)\n    with pytest.raises(ValueError):\n        energy_level(1, 0)\n    with pytest.raises(ValueError):\n        energy_level(0, 0)\n    with pytest.raises(ValueError):\n        energy_level(-1, 2)\n    with pytest.raises(ValueError):\n        energy_level(2, -3)\n    with pytest.raises(ValueError):\n        energy_level(1.5, 3)\n    with pytest.raises(ValueError):\n        energy_level(3, \"4\")\n```\n\nSave the code in `hydrogen_energy.py`, and the tests in `test_hydrogen_energy.py`. To run the tests, just execute `pytest test_hydrogen_energy.py` in your terminal."}, {"key": "ConceptualPromptV2_58", "prompt": "Write a Python program to implement the A* search algorithm for pathfinding in a 2D grid. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python program implementing the A* search algorithm for a 2D grid:\n\n```python\nimport heapq\n\nclass Node:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.neighbors = []\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        return f\"Node({self.x}, {self.y})\"\n\n    def add_neighbors(self, grid):\n        if self.x > 0:\n            self.neighbors.append(grid[self.x - 1][self.y])\n        if self.x < len(grid)-1:\n            self.neighbors.append(grid[self.x + 1][self.y])\n        if self.y > 0:\n            self.neighbors.append(grid[self.x][self.y - 1])\n        if self.y < len(grid[0])-1:\n            self.neighbors.append(grid[self.x][self.y + 1])\n\ndef create_grid(width, height):\n    return [[Node(x, y) for y in range(height)] for x in range(width)]\n\ndef heuristic_cost_estimate(node, goal_node):\n    return abs(node.x - goal_node.x) + abs(node.y - goal_node.y)\n\ndef reconstruct_path(came_from, current):\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    return path[::-1]\n\ndef a_star_search(grid, start, goal):\n    start_node = grid[start[0]][start[1]]\n    goal_node = grid[goal[0]][goal[1]]\n\n    for row in grid:\n        for node in row:\n            node.add_neighbors(grid)\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    g_score = {node: float(\"inf\") for row in grid for node in row}\n    g_score[start_node] = 0\n    f_score = {node: float(\"inf\") for row in grid for node in row}\n    f_score[start_node] = heuristic_cost_estimate(start_node, goal_node)\n\n    came_from = {}\n\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n\n        if current == goal_node:\n            return reconstruct_path(came_from, current)\n\n        for neighbor in current.neighbors:\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic_cost_estimate(neighbor, goal_node)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None\n\nif __name__ == '__main__':\n    grid = create_grid(10, 10)\n    start = (0, 0)\n    goal = (9, 9)\n\n    path = a_star_search(grid, start, goal)\n    print(path)\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom astar import Node, create_grid, heuristic_cost_estimate, reconstruct_path, a_star_search\n\ndef test_node_equality():\n    n1 = Node(1, 2)\n    n2 = Node(1, 2)\n    assert n1 == n2\n\ndef test_create_grid():\n    grid = create_grid(5, 4)\n    assert len(grid) == 5\n    assert len(grid[0]) == 4\n    assert isinstance(grid[2][3], Node)\n\ndef test_heuristic_cost_estimate():\n    start = Node(1, 1)\n    goal = Node(4, 5)\n    assert heuristic_cost_estimate(start, goal) == 7\n\ndef test_reconstruct_path():\n    grid = create_grid(3, 3)\n\n    came_from = {grid[2][1]: grid[1][1], grid[1][1]: grid[0][1], grid[0][1]: grid[0][0]}\n    current = grid[2][1]\n    path = reconstruct_path(came_from, current)\n\n    assert path == [grid[0][0], grid[0][1], grid[1][1], grid[2][1]]\n\ndef test_a_star_search():\n    grid = create_grid(10, 10)\n    start = (0, 0)\n    goal = (9, 9)\n\n    path = a_star_search(grid, start, goal)\n\n    assert path[0] == grid[0][0]\n    assert path[-1] == grid[9][9]\n```\n\nTo run the tests, save the A* search code in a file named `astar.py` and the tests in a file named `test_astar.py`. Then, run `pytest test_astar.py`."}, {"key": "ConceptualPromptV2_9", "prompt": "Write Python code to perform a one-sample t-test to test the mean of a population. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code for performing a one-sample t-test:\n\n```python\nimport numpy as np\nimport scipy.stats as stats\n\ndef generate_sample_data(sample_size, population_mean, population_std_dev):\n    \"\"\"\n    Generate a random sample with specified size, mean, and standard deviation.\n\n    Parameters:\n        sample_size (int): The size of the random sample.\n        population_mean (float): The mean of the population from which the sample is drawn.\n        population_std_dev (float): The standard deviation of the population.\n\n    Returns:\n        np.array: The generated sample data.\n    \"\"\"\n    sample = np.random.normal(loc=population_mean, scale=population_std_dev, size=sample_size)\n    return sample\n\ndef perform_t_test(sample, hypothesized_mean):\n    \"\"\"\n    Perform a one-sample t-test on the given sample with a specified mean to test against.\n\n    Parameters:\n        sample (np.array): The sample data.\n        hypothesized_mean (float): The mean to test against.\n\n    Returns:\n        tuple: A tuple containing the t-statistic and the p-value.\n    \"\"\"\n    t_statistic, p_value = stats.ttest_1samp(a=sample, popmean=hypothesized_mean)\n    return t_statistic, p_value\n\ndef main():\n    sample_size = 50\n    population_mean = 100\n    population_std_dev = 10\n    hypothesized_mean = 105\n\n    sample = generate_sample_data(sample_size, population_mean, population_std_dev)\n    t_statistic, p_value = perform_t_test(sample, hypothesized_mean)\n\n    print(f\"T-statistic: {t_statistic}\")\n    print(f\"P-value: {p_value}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nAnd here's a set of pytest tests to exercise the functions:\n\n```python\nimport pytest\nimport numpy as np\n\nfrom one_sample_t_test import generate_sample_data, perform_t_test\n\ndef test_generate_sample_data():\n    sample_size = 100\n    population_mean = 50\n    population_std_dev = 5\n    sample = generate_sample_data(sample_size, population_mean, population_std_dev)\n\n    assert isinstance(sample, np.ndarray)\n    assert sample.size == sample_size\n    assert np.isclose(np.mean(sample), population_mean, atol=1e-1, rtol=1e-1)\n    assert np.isclose(np.std(sample), population_std_dev, atol=1e-1, rtol=1e-1)\n\ndef test_perform_t_test():\n    sample = np.array([5, 7, 3, 2, 8, 12, 10, 11, 9, 9])\n    hypothesized_mean = 8\n\n    t_statistic, p_value = perform_t_test(sample, hypothesized_mean)\n\n    assert isinstance(t_statistic, float)\n    assert isinstance(p_value, float)\n\n    # Using an assert for known value from the sample data\n    assert np.isclose(t_statistic, -1.8551, atol=1e-4, rtol=1e-4)\n    assert np.isclose(p_value, 0.08637, atol=1e-4, rtol=1e-4)\n\nif __name__ == \"__main__\":\n    pytest.main()\n```"}, {"key": "ConceptualPromptV2_33", "prompt": "Develop Python code to calculate the heat transfer by conduction between two objects, given their thermal conductivities, temperatures, and the distance between them. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code block that calculates the heat transfer by conduction between two objects. The code is modular, well-commented, and uses realistic values for the example:\n\n```python\nimport math\n\ndef heat_transfer_by_conduction(k1, k2, t1, t2, d):\n    \"\"\"\n    Calculate the heat transfer by conduction between two objects.\n    \n    :param k1: float -- thermal conductivity of the first object (W/(m*K))\n    :param k2: float -- thermal conductivity of the second object (W/(m*K))\n    :param t1: float -- temperature of the first object (K)\n    :param t2: float -- temperature of the second object (K)\n    :param d: float -- distance between the objects (m)\n    :return: float -- heat transfer by conduction (W)\n    \"\"\"\n    # Calculate the equivalent thermal conductivity of both materials\n    ke = (k1 * k2) / (k1 + k2)\n    \n    # Calculate the temperature difference\n    delta_t = abs(t1 - t2)\n    \n    # Calculate the heat transfer (q) using Fourier's law of heat conduction\n    q = ke * (delta_t / d)\n    \n    return q\n\n# Example values\nk1 = 50.2  # Thermal conductivity of object 1 (W/(m*K))\nk2 = 28.8  # Thermal conductivity of object 2 (W/(m*K))\nt1 = 358.15  # Temperature of object 1 (K)\nt2 = 295.15  # Temperature of object 2 (K))\nd = 0.25  # Distance between objects (m)\n\n# Calculate the heat transfer by conduction\nq = heat_transfer_by_conduction(k1, k2, t1, t2, d)\nprint(f\"Heat transfer by conduction: {q} W\")\n```\n\nHere is a separate code block with pytest tests that exercises each of the functions:\n\n```python\nimport pytest\nfrom heat_transfer import heat_transfer_by_conduction\n\ndef test_heat_transfer_by_conduction():\n    k1 = 50.2\n    k2 = 28.8\n    t1 = 358.15\n    t2 = 295.15\n    d = 0.25\n    result = heat_transfer_by_conduction(k1, k2, t1, t2, d)\n    assert math.isclose(result, 520.986, rel_tol=1e-3)\n\ndef test_heat_transfer_with_negative_distance():\n    k1 = 50.2\n    k2 = 28.8\n    t1 = 358.15\n    t2 = 295.15\n    d = -0.25\n    with pytest.raises(ValueError):\n        heat_transfer_by_conduction(k1, k2, t1, t2, d)\n```\n\nPlease note that you need to save the first code block into a Python file (e.g., `heat_transfer.py`) and then import the appropriate function in the test file. In the test example, I assumed the file is named `heat_transfer.py`."}, {"key": "ConceptualPromptV2_57", "prompt": "Create a Python code to perform a topological sort on a directed acyclic graph (DAG). Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to perform a topological sort on a directed acyclic graph (DAG):\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def topological_sort_util(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.topological_sort_util(i, visited, stack)\n        stack.insert(0, v)\n\n    def topological_sort(self):\n        visited = [False] * self.V\n        stack = []\n        for i in range(self.V):\n            if visited[i] == False:\n                self.topological_sort_util(i, visited, stack)\n        return stack\n\nif __name__ == '__main__':\n    g = Graph(6)\n    g.add_edge(5, 2)\n    g.add_edge(5, 0)\n    g.add_edge(4, 0)\n    g.add_edge(4, 1)\n    g.add_edge(2, 3)\n    g.add_edge(3, 1)\n\n    print(\"Topological Sort:\")\n    print(g.topological_sort())\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom topological_sort import Graph\n\ndef test_add_edge():\n    g = Graph(2)\n    g.add_edge(0, 1)\n    assert g.graph == {0: [1]}\n\ndef test_topological_sort_util():\n    g = Graph(2)\n    g.add_edge(0, 1)\n    visited = [False] * 2\n    stack = []\n    g.topological_sort_util(0, visited, stack)\n    assert stack == [1, 0]\n\ndef test_topological_sort():\n    g = Graph(6)\n    g.add_edge(5, 2)\n    g.add_edge(5, 0)\n    g.add_edge(4, 0)\n    g.add_edge(4, 1)\n    g.add_edge(2, 3)\n    g.add_edge(3, 1)\n    assert g.topological_sort() == [5, 4, 2, 3, 1, 0]\n```\n\nMake sure to save the first Python code block in a file named `topological_sort.py` and the second code block in a file named `test_topological_sort.py` so that you can run the pytest tests properly."}, {"key": "ConceptualPromptV2_13", "prompt": "Generate Python code to calculate the information gain for a decision tree classifier. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to calculate the information gain for a decision tree classifier:\n\n```python\nimport math\nfrom collections import Counter\n\ndef entropy(y):\n    \"\"\"\n    Calculate the entropy for a list of class labels.\n    \"\"\"\n    counts = Counter(y)\n    total = len(y)\n    entropy_score = sum(-count/total * math.log2(count/total) for count in counts.values())\n    return entropy_score\n\ndef information_gain(x, y, feature_idx):\n    \"\"\"\n    Calculate the information gain for a given feature.\n    Args:\n        x: 2D list of features\n        y: 1D list of class labels\n        feature_idx: Index of the feature we're considering\n    \"\"\"\n    total_entropy = entropy(y)\n    \n    # split the data by feature values\n    split_data = {}\n    for row, label in zip(x, y):\n        feature_value = row[feature_idx]\n        if feature_value not in split_data:\n            split_data[feature_value] = ([], [])\n        split_data[feature_value][0].append(row)\n        split_data[feature_value][1].append(label)\n    \n    # calculate the weighted sum of entropies for each subset\n    weighted_entropy_sum = 0\n    total = len(y)\n    for x_subset, y_subset in split_data.values():\n        weight = len(y_subset) / total\n        subset_entropy = entropy(y_subset)\n        weighted_entropy_sum += weight * subset_entropy\n\n    # information gain is the difference between total entropy and summed weighted entropy\n    gain = total_entropy - weighted_entropy_sum\n    return gain\n\n# Example data\nx = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [0, 0, 1],\n    [1, 1, 0],\n    [0, 1, 1]\n]\n\ny = [1, 0, 0, 1, 0]\n\n# Calculate the information gain for the first feature, index 0\ngain = information_gain(x, y, 0)\nprint(\"Information Gain:\", gain)\n```\n\nFor testing the functions with pytest, you can create a separate file `test_decision_tree.py` and paste the following code:\n\n```python\nimport pytest\nfrom decision_tree import entropy, information_gain\n\ndef test_entropy():\n    assert entropy([1, 1, 0, 0]) == 1.0\n    assert entropy([1, 1, 1, 1]) == 0.0\n    assert pytest.approx(entropy([1, 0, 1, 0, 0]), abs=1e-6) == 0.97095\n\ndef test_information_gain():\n    x = [\n        [1, 0, 1],\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 1, 0],\n        [0, 1, 1]\n    ]\n    y = [1, 0, 0, 1, 0]\n\n    assert pytest.approx(information_gain(x, y, 0), abs=1e-6) == 0.01997\n    assert pytest.approx(information_gain(x, y, 1), abs=1e-6) == 0.41997\n    assert pytest.approx(information_gain(x, y, 2), abs=1e-6) == 0.01997\n```\n\nTo run the tests, simply execute the `pytest` command in your terminal after installing pytest with pip:\n\n```\npip install pytest\npytest\n```"}, {"key": "ConceptualPromptV2_85", "prompt": "Create a Python code to calculate the economic profit of a firm, given its total revenue, total cost, and opportunity cost. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to calculate the economic profit of a firm:\n\n```python\ndef calculate_economic_profit(total_revenue, total_cost, opportunity_cost):\n    \"\"\"\n    Calculate the economic profit of a firm.\n\n    Args:\n    total_revenue (float): The firm's total revenue.\n    total_cost (float): The firm's total cost.\n    opportunity_cost (float): The opportunity cost for the firm's investment.\n\n    Returns:\n    float: Economic profit calculated as total_revenue - total_cost - opportunity_cost.\n    \"\"\"\n    economic_profit = total_revenue - total_cost - opportunity_cost\n    return economic_profit\n\n# Example usage:\ntotal_revenue = 100000\ntotal_cost = 80000\nopportunity_cost = 5000\n\neconomic_profit = calculate_economic_profit(total_revenue, total_cost, opportunity_cost)\nprint(\"Economic Profit:\", economic_profit)\n```\n\nHere's a set of pytest tests for the `calculate_economic_profit` function:\n\n```python\nimport pytest\nfrom economic_profit import calculate_economic_profit\n\ndef test_calculate_economic_profit_positive():\n    assert calculate_economic_profit(100000, 80000, 5000) == 15000\n\ndef test_calculate_economic_profit_zero():\n    assert calculate_economic_profit(100000, 95000, 5000) == 0\n\ndef test_calculate_economic_profit_negative():\n    assert calculate_economic_profit(100000, 105000, 5000) == -10000\n\ndef test_calculate_economic_profit_invalid_arguments():\n    with pytest.raises(TypeError):\n        calculate_economic_profit(\"100000\", \"80000\", \"5000\")\n```"}, {"key": "ConceptualPromptV2_10", "prompt": "Generate Python code to compute the Gini index for a given dataset, as a measure of inequality. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python script to compute the Gini index for a given dataset:\n\n```python\nimport numpy as np\n\ndef gini_coefficient(dataset):\n    \"\"\"\n    Compute the Gini coefficient of a given dataset.\n    Args:\n    - dataset (list): A list of numerical values representing the dataset.\n    Returns:\n    - float: The Gini coefficient.\n    \"\"\"\n    dataset = np.array(dataset)\n    n = len(dataset)\n    dataset_sorted = np.sort(dataset)\n    index = np.arange(1, n+1)\n    gini = (np.sum((2 * index - n - 1) * dataset_sorted)) / (n * np.sum(dataset_sorted))\n    \n    return gini\n\ndef main():\n    # Example dataset\n    dataset = [60000, 30000, 10000, 5000, 20000, 40000, 70000, 80000]\n    gini_index = gini_coefficient(dataset)\n    print(f\"The Gini index for the given dataset is: {gini_index:.4f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow, here are some pytest tests to exercise each function:\n\n```python\nimport pytest\nfrom gini import gini_coefficient\n\ndef test_gini_coefficient():\n    # With a uniform dataset\n    dataset1 = [1, 1, 1, 1, 1]\n    assert gini_coefficient(dataset1) == 0.0\n\n    # With an ascending dataset\n    dataset2 = [1, 2, 3, 4, 5, 6, 7]\n    assert pytest.approx(gini_coefficient(dataset2), 0.2381)\n\n    # With a descending dataset\n    dataset3 = [7, 6, 5, 4, 3, 2, 1]\n    assert pytest.approx(gini_coefficient(dataset3), 0.2381)\n\n    # With a mixed dataset\n    dataset4 = [1, 7, 2, 6, 3, 5, 4]\n    assert pytest.approx(gini_coefficient(dataset4), 0.2381)\n\n    # With a dataset containing duplicate values\n    dataset5 = [3, 3, 3, 4, 4, 5, 5, 5]\n    assert pytest.approx(gini_coefficient(dataset5), 0.1042)\n\n```\nSave the Python script as \"gini.py\" and the test script as \"test_gini.py\". Run the tests using pytest by executing the command `pytest test_gini.py`."}, {"key": "ConceptualPromptV2_68", "prompt": "Write a Python code to model the energy flow through a food web, given the trophic levels, energy transfer efficiencies, and primary production rates. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python code implementing the energy flow through a food web:\n\n```python\nimport random\n\n# Example parameters\ntrophic_levels = {\n    'producers': 1,\n    'primary_consumers': 2,\n    'secondary_consumers': 3,\n    'tertiary_consumers': 4\n}\n\nenergy_transfer_efficiencies = {\n    'producers_to_primary': 0.10,\n    'primary_to_secondary': 0.15,\n    'secondary_to_tertiary': 0.07\n}\n\nprimary_production_rate = 1000  # in kcal/m^2/year\n\ndef energy_flow(primary_production_rate, trophic_levels, energy_transfer_efficiencies):\n    energy_levels = {}\n    energy_levels[trophic_levels['producers']] = primary_production_rate\n    energy_levels[trophic_levels['primary_consumers']] = energy_transfer(primary_production_rate, energy_transfer_efficiencies['producers_to_primary'])\n    energy_levels[trophic_levels['secondary_consumers']] = energy_transfer(energy_levels[trophic_levels['primary_consumers']], energy_transfer_efficiencies['primary_to_secondary'])\n    energy_levels[trophic_levels['tertiary_consumers']] = energy_transfer(energy_levels[trophic_levels['secondary_consumers']], energy_transfer_efficiencies['secondary_to_tertiary'])\n\n    return energy_levels\n\ndef energy_transfer(energy_in, efficiency):\n    return energy_in * efficiency\n\nenergy_flow_result = energy_flow(primary_production_rate, trophic_levels, energy_transfer_efficiencies)\nprint(energy_flow_result)\n```\n\nThis code defines a food web, trophic levels, and energy transfer efficiencies. The `energy_flow()` function, computes the energy flow in each trophic level using the `energy_transfer()` function.\n\nHere is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom energy_flow import energy_flow, energy_transfer\n\n@pytest.mark.parametrize(\"energy_in, efficiency, expected_result\", [\n    (1000, 0.10, 100),\n    (2000, 0.15, 300),\n    (500, 0.50, 250),\n    (1200, 0.05, 60),\n])\ndef test_energy_transfer(energy_in, efficiency, expected_result):\n    assert energy_transfer(energy_in, efficiency) == expected_result\n\ntrophic_levels_example = {\n    'producers': 1,\n    'primary_consumers': 2,\n    'secondary_consumers': 3,\n    'tertiary_consumers': 4\n}\n\nenergy_transfer_efficiencies_example = {\n    'producers_to_primary': 0.10,\n    'primary_to_secondary': 0.15,\n    'secondary_to_tertiary': 0.07\n}\n\ndef test_energy_flow():\n    energy_flow_result = energy_flow(1000, trophic_levels_example, energy_transfer_efficiencies_example)\n    \n    assert energy_flow_result[1] == 1000\n    assert energy_flow_result[2] == 100\n    assert energy_flow_result[3] == 15\n    assert energy_flow_result[4] == 1.05\n```\n\nThe test suite uses pytest and includes test cases for the `energy_transfer()` function and a test for the `energy_flow()` function with example parameters."}, {"key": "ConceptualPromptV2_90", "prompt": "Write a Python program to determine the breakeven point for a firm, given its fixed costs, variable costs, and the selling price per unit. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python program to determine the breakeven point for a firm:\n\n```python\ndef breakeven_point(fixed_costs, variable_costs, selling_price):\n    \"\"\"\n    Calculate the breakeven point given fixed costs, variable costs, and selling price per unit.\n\n    :param fixed_costs: The fixed costs of the firm.\n    :param variable_costs: The variable costs per unit.\n    :param selling_price: The selling price per unit.\n    :return: The breakeven point.\n    \"\"\"\n    if selling_price <= variable_costs:\n        return -1  # Breakeven point cannot be reached if selling price is less than variable costs.\n    \n    breakeven_units = fixed_costs / (selling_price - variable_costs)\n    return round(breakeven_units)\n\n# Example values\nfixed_costs_example = 10000\nvariable_costs_example = 30\nselling_price_example = 50\n\nbreakeven_units = breakeven_point(fixed_costs_example, variable_costs_example, selling_price_example)\nprint(f\"Breakeven point: {breakeven_units} units\")\n```\n\nAnd here is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom breakeven import breakeven_point\n\n@pytest.mark.parametrize(\"fixed_costs, variable_costs, selling_price, expected\", [\n    (10000, 30, 50, 500),\n    (0, 30, 50, 0),\n    (5000, 10, 20, 500),\n    (1000, 35, 35, -1),\n])\ndef test_breakeven_point(fixed_costs, variable_costs, selling_price, expected):\n    assert breakeven_point(fixed_costs, variable_costs, selling_price) == expected\n```\n\nYou'll need to ensure that the `breakeven` function is in a separate file called `breakeven.py`. Then, simply run `pytest` in the command line to execute the tests."}, {"key": "ConceptualPromptV2_97", "prompt": "Create a Python function to compute the Herfindahl-Hirschman Index (HHI) for market concentration, given the market shares of all firms in the market. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python function to compute the Herfindahl-Hirschman Index (HHI) for market concentration, given the market shares of all firms in the market:\n\n```python\ndef calculate_hhi(market_shares):\n    \"\"\"\n    Calculate the Herfindahl-Hirschman Index (HHI) for market concentration.\n    \n    Args:\n        market_shares (list): A list of market shares for each firm, where each share is a float between 0 and 1.\n\n    Returns:\n        float: The HHI for the given market shares, rounded to 2 decimal places.\n    \"\"\"\n    if not market_shares:\n        raise ValueError(\"Market shares cannot be empty\")\n\n    hhi = sum([share * share for share in market_shares]) * 10000\n    return round(hhi, 2)\n```\n\nAnd here are some pytest tests to test this function:\n\n```python\nimport pytest\nfrom hhi import calculate_hhi\n\ndef test_calculate_hhi_valid_input():\n    market_shares = [0.5, 0.3, 0.2]\n    expected_hhi = 3800\n    assert calculate_hhi(market_shares) == expected_hhi\n\ndef test_calculate_hhi_empty_market_shares():\n    with pytest.raises(ValueError):\n        calculate_hhi([])\n\ndef test_calculate_hhi_single_firm():\n    market_shares = [1]\n    expected_hhi = 10000\n    assert calculate_hhi(market_shares) == expected_hhi\n```"}, {"key": "ConceptualPromptV2_65", "prompt": "Create a Python code to model the spread of an invasive species in an ecosystem, given the growth rate, dispersal rate, and initial population size. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to model the spread of an invasive species in an ecosystem:\n\n```python\nimport random\n\nclass InvasiveSpecies:\n    \n    def __init__(self, initial_population, growth_rate, dispersal_rate):\n        self.population = initial_population\n        self.growth_rate = growth_rate\n        self.dispersal_rate = dispersal_rate\n        \n    def grow_population(self):\n        self.population += int(self.population * self.growth_rate)\n        \n    def disperse_species(self):\n        dispersed_population = int(self.population * self.dispersal_rate)\n        self.population -= dispersed_population\n        return dispersed_population\n\n    def simulate_growth(self, steps):\n        results = []\n        for _ in range(steps):\n            self.grow_population()\n            dispersed_population = self.disperse_species()\n            results.append((self.population, dispersed_population))\n        return results\n\ninitial_population = 100\ngrowth_rate = 0.5\ndispersal_rate = 0.1\n\nspecies = InvasiveSpecies(initial_population, growth_rate, dispersal_rate)\nsimulation_steps = 10\n\nresults = species.simulate_growth(simulation_steps)\nfor step, (population, dispersed_population) in enumerate(results, start=1):\n    print(f\"Step {step}: Population = {population}, Dispersed Population = {dispersed_population}\")\n```\n\nHere's a set of pytest tests for each function in the InvasiveSpecies class:\n\n```python\nimport pytest\nfrom invasive_species import InvasiveSpecies\n\n@pytest.fixture\ndef species():\n    return InvasiveSpecies(100, 0.5, 0.1)\n\ndef test_grow_population(species):\n    species.grow_population()\n    assert species.population == 150\n\ndef test_disperse_species(species):\n    dispersed_population = species.disperse_species()\n    assert dispersed_population == 10\n    assert species.population == 90\n\ndef test_simulate_growth(species):\n    results = species.simulate_growth(3)\n    assert len(results) == 3\n    assert results[0] == (135, 13)\n    assert results[1] == (185, 18)\n    assert results[2] == (251, 25)\n```"}, {"key": "ConceptualPromptV2_66", "prompt": "Write a Python program to simulate the carbon cycle in an ecosystem, given the rates of photosynthesis, respiration, decomposition, and carbon sequestration. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a simple Python program to simulate the carbon cycle in an ecosystem. Note that this is only a basic model and can be improved with more accurate representation of the ecosystem.\n\n```python\nimport random\n\ndef photosynthesis_rate():\n    return random.uniform(40, 200)\n\ndef respiration_rate():\n    return random.uniform(30, 150)\n\ndef decomposition_rate():\n    return random.uniform(10, 80)\n\ndef carbon_sequestration_rate():\n    return random.uniform(5, 50)\n\ndef carbon_cycle_simulation(steps):\n    carbon_reservoirs = {\n        'atmosphere': 1000,\n        'vegetation': 1000,\n        'soil': 1000\n    }\n\n    for _ in range(steps):\n        photosynthesis = photosynthesis_rate()\n        respiration   = respiration_rate()\n        decomposition = decomposition_rate()\n        sequestration = carbon_sequestration_rate()\n\n        carbon_reservoirs['atmosphere'] -= photosynthesis\n        carbon_reservoirs['vegetation'] += (photosynthesis - respiration)\n        carbon_reservoirs['soil'] += respiration + decomposition - sequestration\n\n        # Ensure no negative values in carbon reservoirs\n        for reservoir in carbon_reservoirs:\n            carbon_reservoirs[reservoir] = max(0, carbon_reservoirs[reservoir])\n    \n    return carbon_reservoirs\n\nif __name__ == \"__main__\":\n    steps = 100\n    carbon_cycle_results = carbon_cycle_simulation(steps)\n    print(carbon_cycle_results)\n```\n\nNow, let's create a set of pytest tests for each of the functions.\n\n```python\nimport pytest\nfrom carbon_cycle_simulation import photosynthesis_rate, respiration_rate, decomposition_rate, carbon_sequestration_rate, carbon_cycle_simulation\n\ndef test_photosynthesis_rate():\n    for _ in range(100):\n        rate = photosynthesis_rate()\n        assert 40 <= rate <= 200\n\ndef test_respiration_rate():\n    for _ in range(100):\n        rate = respiration_rate()\n        assert 30 <= rate <= 150\n\ndef test_decomposition_rate():\n    for _ in range(100):\n        rate = decomposition_rate()\n        assert 10 <= rate <= 80\n\ndef test_carbon_sequestration_rate():\n    for _ in range(100):\n        rate = carbon_sequestration_rate()\n        assert 5 <= rate <= 50\n\ndef test_carbon_cycle_simulation():\n    steps = 100\n    carbon_cycle_results = carbon_cycle_simulation(steps)\n    assert len(carbon_cycle_results) == 3\n    assert \"atmosphere\" in carbon_cycle_results\n    assert \"vegetation\" in carbon_cycle_results\n    assert \"soil\" in carbon_cycle_results\n    assert isinstance(carbon_cycle_results[\"atmosphere\"], (int, float))\n    assert isinstance(carbon_cycle_results[\"vegetation\"], (int, float))\n    assert isinstance(carbon_cycle_results[\"soil\"], (int, float))\n```\n\nTo run the tests, install pytest, save the simulation script as `carbon_cycle_simulation.py` and the tests as `test_carbon_cycle_simulation.py`. Then, run the command `pytest` in your terminal."}, {"key": "ConceptualPromptV2_31", "prompt": "Create Python code to calculate the centripetal force acting on an object in circular motion, given its mass, velocity, and radius of the circle. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to calculate the centripetal force acting on an object in circular motion:\n\n```python\ndef centripetal_force(mass, velocity, radius):\n    \"\"\"\n    Calculate the centripetal force acting on an object in circular motion.\n    \n    Args:\n    mass (float): Mass of the object in kg\n    velocity (float): Velocity of the object in m/s\n    radius (float): Radius of the circular path in meters\n    \n    Returns:\n    float: Centripetal force in Newtons\n    \"\"\"\n    force = (mass * velocity**2) / radius\n    return force\n\n# Example: Mass = 5 kg, Velocity = 10 m/s, Radius = 2 meters\nmass = 5\nvelocity = 10\nradius = 2\n\ncentripetal_force_value = centripetal_force(mass, velocity, radius)\nprint(f\"Centripetal force: {centripetal_force_value} N\")\n```\n\nHere's a set of pytest tests for the centripetal_force function:\n\n```python\nimport pytest\nfrom centripetal_force_calculator import centripetal_force\n\ndef test_positive_values():\n    result = centripetal_force(5, 10, 2)\n    assert result == 250\n\ndef test_zero_mass():\n    result = centripetal_force(0, 10, 2)\n    assert result == 0\n\ndef test_zero_velocity():\n    result = centripetal_force(5, 0, 2)\n    assert result == 0\n\ndef test_negative_values():\n    with pytest.raises(ValueError):\n        centripetal_force(-5, 10, 2)\n\n    with pytest.raises(ValueError):\n        centripetal_force(5, -10, 2)\n\n    with pytest.raises(ValueError):\n        centripetal_force(5, 10, -2)\n```\n\nRemember to save the centripetal force calculation code in a file named `centripetal_force_calculator.py` and the pytest test code in a separate file named `test_centripetal_force_calculator.py`. You can then run the tests using the `pytest` command in your terminal."}, {"key": "ConceptualPromptV2_36", "prompt": "Write Python code to calculate the torque on an object due to a force, given the force, the distance from the pivot point, and the angle between the force and the lever arm. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to calculate the torque on an object:\n\n```python\nimport math\n\ndef torque(force, distance, angle):\n    \"\"\"\n    Calculate the torque on an object given the force, the distance from the pivot\n    point, and the angle between the force and the lever arm.\n\n    :param force: The force applied to the object (in Newtons).\n    :param distance: The distance from the pivot point to the point where the force is applied (in meters).\n    :param angle: The angle in degrees between the force and the lever arm.\n    :return: The torque on the object (in Newton-meters).\n    \"\"\"\n    angle_in_radians = math.radians(angle)\n    return force * distance * math.sin(angle_in_radians)\n\n# Example values\nforce = 50  # Newtons\ndistance = 2  # meters\nangle = 30  # degrees\n\ntorque_value = torque(force, distance, angle)\nprint(f\"The torque on the object is {torque_value:.2f} Nm\")\n```\n\nHere are the pytest tests to ensure the correctness of the functions:\n\n```python\nimport pytest\nfrom torque_calculator import torque\n\ndef test_torque():\n    assert pytest.approx(torque(50, 2, 30), 0.0001) == 50.0\n    assert pytest.approx(torque(50, 2, 0), 0.0001) == 0.0\n    assert pytest.approx(torque(50, 2, 180), 0.0001) == 0.0\n    assert pytest.approx(torque(50, 2, 90), 0.0001) == 100.0\n    assert pytest.approx(torque(100, 3, 45), 0.0001) == 212.1320\n"}, {"key": "ConceptualPromptV2_92", "prompt": "Write a Python function to model the Phillips curve, which shows the relationship between inflation and unemployment, given the inflation rate, natural rate of unemployment, and the output gap. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function that models the Phillips curve:\n\n```python\ndef phillips_curve(inflation_rate, natural_rate_of_unemployment, output_gap, alpha=0.5, beta=0.5):\n    \"\"\"\n    Model the Phillips curve.\n    \n    Args:\n    inflation_rate (float): The current inflation rate.\n    natural_rate_of_unemployment (float): The natural rate of unemployment.\n    output_gap (float): The output gap.\n    alpha (float, optional): The parameter representing the sensitivity of inflation to changes in output gap. Default to 0.5.\n    beta (float, optional): The parameter representing the persistence of inflation. Default to 0.5.\n\n    Returns:\n    float: The predicted unemployment rate.\n    \"\"\"\n    expected_inflation = beta * inflation_rate\n    unemployment_rate = natural_rate_of_unemployment - alpha * output_gap\n    return unemployment_rate, expected_inflation\n```\n\nAnd here are the pytest tests to exercise the `phillips_curve` function:\n\n```python\nimport pytest\nfrom phillips_curve import phillips_curve\n\ndef test_phillips_curve_positive_output_gap():\n    unemployment_rate, expected_inflation = phillips_curve(0.03, 0.05, 0.02)\n    assert unemployment_rate < 0.05\n    assert expected_inflation == 0.03 * 0.5\n\ndef test_phillips_curve_negative_output_gap():\n    unemployment_rate, expected_inflation = phillips_curve(0.03, 0.05, -0.02)\n    assert unemployment_rate > 0.05\n    assert expected_inflation == 0.03 * 0.5\n\ndef test_phillips_curve_zero_output_gap():\n    unemployment_rate, expected_inflation = phillips_curve(0.03, 0.05, 0)\n    assert unemployment_rate == 0.05\n    assert expected_inflation == 0.03 * 0.5\n\ndef test_phillips_curve_custom_alpha_beta():\n    alpha = 0.4\n    beta = 0.8\n    unemployment_rate, expected_inflation = phillips_curve(0.03, 0.05, 0.02, alpha=alpha, beta=beta)\n    assert unemployment_rate == 0.05 - alpha * 0.02\n    assert expected_inflation == 0.03 * beta\n```"}, {"key": "ConceptualPromptV2_84", "prompt": "Write a Python function to model the production function of a firm, given the input quantities and their respective production elasticities. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function that models the production function of a firm, given the input quantities and their respective production elasticities:\n\n```python\ndef production_function(input_quantities, elasticities):\n    \"\"\"\n    Calculate the production output of a firm, given the input quantities and their respective production elasticities.\n\n    :param input_quantities: list of input quantities\n    :param elasticities: list of production elasticities for each input\n    :return: total production output\n    \"\"\"\n    if len(input_quantities) != len(elasticities):\n        raise ValueError(\"Input quantities and elasticities must have the same length.\")\n\n    output = 1\n    for q, e in zip(input_quantities, elasticities):\n        output *= q ** e\n    return output\n\n\n# Example usage:\ninput_quantities = [100, 200, 300]\nelasticities = [0.3, 0.4, 0.3]\n\nproduction_output = production_function(input_quantities, elasticities)\nprint(f\"Production output: {production_output}\")\n```\n\nFor testing the function using `pytest`, you can write the following test cases:\n\n```python\nimport pytest\nfrom production_function import production_function\n\n\ndef test_production_function_valid():\n    input_quantities = [100, 200, 300]\n    elasticities = [0.3, 0.4, 0.3]\n    assert production_function(input_quantities, elasticities) == 100 ** 0.3 * 200 ** 0.4 * 300 ** 0.3\n\n\ndef test_production_function_zero_inputs():\n    input_quantities = [0, 0, 0]\n    elasticities = [0.3, 0.4, 0.3]\n    assert production_function(input_quantities, elasticities) == 0\n\n\ndef test_production_function_zero_elasticities():\n    input_quantities = [100, 200, 300]\n    elasticities = [0, 0, 0]\n    assert production_function(input_quantities, elasticities) == 1\n\n\ndef test_production_function_mismatched_lengths():\n    input_quantities = [100, 200, 300]\n    elasticities = [0.3, 0.4]\n    with pytest.raises(ValueError):\n        production_function(input_quantities, elasticities)\n```\n\nNote that to run the tests, you will need to have `pytest` installed. You can install it using `pip`:\n\n```\npip install pytest\n```"}, {"key": "ConceptualPromptV2_17", "prompt": "Write Python code to perform time series forecasting using the ARIMA (Autoregressive Integrated Moving Average) model. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code implementing the ARIMA model for time series forecasting:\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom statsmodels.tsa.arima.model import ARIMA\nimport matplotlib.pyplot as plt\n\ndef generate_data():\n    # Generating a random time series data as an example\n    np.random.seed(42)\n    n = 100\n    data = np.random.normal(size=n)\n    data = np.cumsum(data)\n    return pd.Series(data)\n\ndef create_arima_model(data, order=(1, 1, 1)):\n    \"\"\"\n    This function creates the ARIMA model given the input data and order.\n    \n    :param data: Time series data as a pandas Series\n    :param order: A tuple of p, d, and q for the ARIMA model (default: (1, 1, 1))\n    :return: An instance of the ARIMA model\n    \"\"\"\n    model = ARIMA(data, order=order)\n    return model\n\ndef fit_arima_model(model):\n    \"\"\"\n    This function fits the given ARIMA model.\n    \n    :param model: Instance of the ARIMA model\n    :return: A fitted ARIMA model\n    \"\"\"\n    fitted_model = model.fit()\n    return fitted_model\n\ndef forecast_arima_model(fitted_model, steps=5):\n    \"\"\"\n    This function generates predictions for the given number of steps using the fitted ARIMA model.\n    \n    :param fitted_model: A fitted ARIMA model\n    :param steps: The number of steps to forecast (default: 5)\n    :return: Forecasted values as a pandas Series\n    \"\"\"\n    forecast = fitted_model.forecast(steps=steps)\n    return forecast\n\ndef plot_forecast(data, forecast):\n    \"\"\"\n    This function plots the actual data and the forecasted data.\n    \n    :param data: Time series data as a pandas Series\n    :param forecast: Forecasted values as a pandas Series\n    \"\"\"\n    plt.figure(figsize=(12, 6))\n    plt.plot(data, label='Actual Data')\n    plt.plot(np.arange(len(data), len(data) + len(forecast)), forecast, label='Forecast')\n    plt.legend()\n    plt.show()\n\nif __name__ == '__main__':\n    data = generate_data()\n    arima_model = create_arima_model(data)\n    fitted_model = fit_arima_model(arima_model)\n    forecast = forecast_arima_model(fitted_model)\n    plot_forecast(data, forecast)\n```\n\nNow, here's a set of pytest tests exercising each of the functions:\n\n```python\nimport pytest\nfrom statsmodels.tsa.arima.model import ARIMA\n\ndef test_generate_data():\n    data = generate_data()\n    assert isinstance(data, pd.Series)\n    assert len(data) == 100\n\ndef test_create_arima_model():\n    data = generate_data()\n    arima_model = create_arima_model(data)\n    assert isinstance(arima_model, ARIMA)\n\ndef test_fit_arima_model():\n    data = generate_data()\n    arima_model = create_arima_model(data)\n    fitted_model = fit_arima_model(arima_model)\n    assert fitted_model is not None\n\ndef test_forecast_arima_model():\n    data = generate_data()\n    arima_model = create_arima_model(data)\n    fitted_model = fit_arima_model(arima_model)\n    forecast = forecast_arima_model(fitted_model, steps=5)\n    assert isinstance(forecast, pd.Series)\n    assert len(forecast) == 5\n```"}, {"key": "ConceptualPromptV2_83", "prompt": "Develop a Python code to calculate the consumer and producer surplus in a market, given the supply and demand curves and the market price. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to calculate consumer and producer surplus given supply and demand curves and the market price:\n\n```python\nimport numpy as np\n\n\ndef linear_function(x, a, b):\n    return a * x + b\n\n\ndef inverse_demand(price, a, b):\n    \"\"\"\n    Calculate the quantity demanded for a given price and inverse demand curve parameters a and b.\n    \"\"\"\n    return (price - b) / a\n\n\ndef inverse_supply(price, c, d):\n    \"\"\"\n    Calculate the quantity supplied for a given price and inverse supply curve parameters c and d. \n    \"\"\"\n    return (price - d) / c\n\n\ndef consumer_surplus(quantity, price, a, b):\n    \"\"\"\n    Calculate the consumer surplus given the market quantity, price, and the demand curve parameters a and b.\n    \"\"\"\n    demand_price = linear_function(quantity, a, b)\n    return 0.5 * abs(demand_price - price) * quantity\n\n\ndef producer_surplus(quantity, price, c, d):\n    \"\"\"\n    Calculate the producer surplus given the market quantity, price, and the supply curve parameters c and d.\n    \"\"\"\n    supply_price = linear_function(quantity, c, d)\n    return 0.5 * abs(price - supply_price) * quantity\n\n\n# Demand curve parameters (a, b)\ndemand_params = (-1, 20)\n\n# Supply curve parameters (c, d)\nsupply_params = (1, 10)\n\n# Market price\nmarket_price = 15\n\n# Calculate market equilibrium quantity.\nmarket_quantity = inverse_demand(market_price, *demand_params)\nassert np.allclose(market_quantity, inverse_supply(market_price, *supply_params))\n\n# Calculate consumer surplus.\ncs = consumer_surplus(market_quantity, market_price, *demand_params)\nprint(f\"Consumer Surplus: {cs}\")\n\n# Calculate producer surplus.\nps = producer_surplus(market_quantity, market_price, *supply_params)\nprint(f\"Producer Surplus: {ps}\")\n```\n\nHere's a set of pytest test cases:\n\n```python\nimport pytest\nimport numpy as np\n\n\ndef test_linear_function():\n    assert np.allclose(linear_function(2, 3, 4), 10)\n\n\ndef test_inverse_demand():\n    assert np.allclose(inverse_demand(20, -1, 30), 10)\n\n\ndef test_inverse_supply():\n    assert np.allclose(inverse_supply(20, 1, 10), 10)\n\n\ndef test_consumer_surplus():\n    assert np.allclose(consumer_surplus(10, 15, -1, 20), 25)\n\n\ndef test_producer_surplus():\n    assert np.allclose(producer_surplus(10, 15, 1, 10), 25)\n```"}, {"key": "ConceptualPromptV2_62", "prompt": "Write a Python program to simulate predator-prey interactions using the Lotka-Volterra equations, given the initial populations, growth rates, and interaction coefficients. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a simple Python program to simulate predator-prey interactions using the Lotka-Volterra equations:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef lotka_volterra_function(state, t, alpha, beta, gamma, delta):\n    x, y = state\n    dxdt = alpha * x - beta * x * y\n    dydt = -gamma * y + delta * x * y\n    return np.array([dxdt, dydt])\n\ndef simulate_predator_prey(initial_population, timesteps, alpha, beta, gamma, delta):\n    state = np.zeros((timesteps, 2))\n    state[0] = initial_population\n    dt = 1\n\n    for t in range(1, timesteps):\n        state[t] = state[t - 1] + dt * lotka_volterra_function(state[t - 1], t, alpha, beta, gamma, delta)\n\n    return state\n\ndef plot_simulation(state):\n    plt.figure()\n    plt.plot(state[:, 0], label='Prey')\n    plt.plot(state[:, 1], label='Predator')\n    plt.legend()\n    plt.xlabel('Time')\n    plt.ylabel('Population')\n    plt.show()\n\nif __name__ == '__main__':\n    initial_population = np.array([40, 9])\n    timesteps = 200\n    alpha = 1.1\n    beta = 0.4\n    gamma = 0.4\n    delta = 0.1\n    \n    state = simulate_predator_prey(initial_population, timesteps, alpha, beta, gamma, delta)\n    plot_simulation(state)\n```\n\nNow, let's create a set of pytest tests that exercise each of the functions:\n\n```python\nimport numpy as np\nimport pytest\nfrom predator_prey_simulation import lotka_volterra_function, simulate_predator_prey\n\ndef test_lotka_volterra_function():\n    state = np.array([50, 10])\n    t = 1\n    alpha = 1.1\n    beta = 0.4\n    gamma = 0.4\n    delta = 0.1\n    expected = np.array([45., -30.])\n    np.testing.assert_array_almost_equal(lotka_volterra_function(state, t, alpha, beta, gamma, delta), expected)\n\ndef test_simulate_predator_prey():\n    initial_population = np.array([40, 9])\n    timesteps = 3\n    alpha = 1.1\n    beta = 0.4\n    gamma = 0.4\n    delta = 0.1\n    expected = np.array([[ 40.,   9.],\n                         [ 44.,   5.6],\n                         [ 47.84,  3.472]])\n    np.testing.assert_array_almost_equal(simulate_predator_prey(initial_population, timesteps, alpha, beta, gamma, delta), expected)\n\nif __name__ == '__main__':\n    pytest.main([__file__])\n```\n\nJust save the first code block as `predator_prey_simulation.py` and the second code block as `test_predator_prey_simulation.py` and run `pytest test_predator_prey_simulation.py` in the terminal/command prompt to execute the tests."}, {"key": "ConceptualPromptV2_38", "prompt": "Create a Python function to calculate the pressure exerted by a gas, given its volume, temperature, and the number of moles using the ideal gas law. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function implementing the ideal gas law:\n\n```python\ndef ideal_gas_pressure(volume, temperature, moles):\n    \"\"\"\n    Calculate the pressure exerted by a gas using the ideal gas law.\n\n    :param volume: The volume of the gas in liters (L)\n    :param temperature: The temperature of the gas in Kelvin (K)\n    :param moles: The amount of substance (moles) of the gas (n)\n    :return: The pressure of the gas in Pascals (Pa)\n    \"\"\"\n    R = 8.3145  # Ideal gas constant in J/(mol\u00b7K)\n\n    # Convert volume from liters to cubic meters\n    volume_m3 = volume * 0.001\n\n    # Calculate pressure using ideal gas law (P = nRT/V)\n    pressure = (moles * R * temperature) / volume_m3\n\n    return pressure\n\n\n# Example usage\nv = 22.4  # Volume in liters (1 mole of an ideal gas at STP)\nt = 273.15  # Temperature in Kelvin (STP)\nn = 1  # Number of moles\n\npressure = ideal_gas_pressure(v, t, n)\nprint(f\"The pressure exerted by the gas is {pressure:.2f} Pa\")\n```\n\nHere are some pytest tests to check the correctness of the implementation:\n\n```python\nimport pytest\nfrom ideal_gas_pressure import ideal_gas_pressure\n\n\ndef test_zero_volume():\n    with pytest.raises(ZeroDivisionError):\n        ideal_gas_pressure(0, 273.15, 1)\n\n\ndef test_negative_volume():\n    with pytest.raises(ValueError):\n        ideal_gas_pressure(-1, 273.15, 1)\n\n\ndef test_zero_temperature():\n    with pytest.raises(ValueError):\n        ideal_gas_pressure(22.4, 0, 1)\n\n\ndef test_negative_temperature():\n    with pytest.raises(ValueError):\n        ideal_gas_pressure(22.4, -273.15, 1)\n\n\ndef test_zero_moles():\n    assert ideal_gas_pressure(22.4, 273.15, 0) == 0\n\n\ndef test_negative_moles():\n    with pytest.raises(ValueError):\n        ideal_gas_pressure(22.4, 273.15, -1)\n\n\ndef test_ideal_gas_law():\n    v = 22.4  # Volume in liters (1 mole of an ideal gas at STP)\n    t = 273.15  # Temperature in Kelvin (1 mole of an ideal gas at STP)\n    n = 1  # Number of moles\n\n    pressure = ideal_gas_pressure(v, t, n)\n    assert round(pressure) == 101325  # Standard atmospheric pressure in Pascals (Pa)\n```"}, {"key": "ConceptualPromptV2_52", "prompt": "Write a Python code to determine if a given graph is bipartite using the Breadth-First Search (BFS) algorithm. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the Breadth-First Search (BFS) algorithm to check if a given graph is bipartite:\n\n```python\nfrom collections import deque\n\ndef check_bipartite(graph):\n    \"\"\"\n    Function to check if a given graph is bipartite.\n    :param graph: Dictionary representing the graph.\n    :return: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    start_vertex = list(graph.keys())[0]\n    visited = set()\n    color = dict()\n\n    # Create a BFS queue and add the starting vertex with color 0.\n    bfs_queue = deque([(start_vertex, 0)])\n\n    # Process each vertex and its associated color until the BFS queue is empty.\n    while bfs_queue:\n        vertex, vertex_color = bfs_queue.popleft()\n        \n        if vertex not in visited:\n            visited.add(vertex)\n            color[vertex] = vertex_color\n\n            # Check adjacent vertices.\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    bfs_queue.append((neighbor, 1 - vertex_color))\n                elif color[neighbor] == vertex_color:\n                    return False\n\n    return True\n\n\ndef main():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D'],\n        'C': ['A', 'D'],\n        'D': ['B', 'C'],\n        'E': ['F'],\n        'F': ['E']\n    }\n\n    is_bipartite = check_bipartite(graph)\n    print(f\"Is the graph bipartite? {is_bipartite}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nAnd here are the pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom bipartite_graph import check_bipartite\n\ndef test_check_bipartite_true():\n    graph1 = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D'],\n        'C': ['A', 'D'],\n        'D': ['B', 'C'],\n        'E': ['F'],\n        'F': ['E']\n    }\n\n    graph2 = {\n        'A': ['B', 'C', 'D'],\n        'B': ['A', 'E'],\n        'C': ['A', 'E'],\n        'D': ['A', 'E'],\n        'E': ['B', 'C', 'D'],\n    }\n\n    assert check_bipartite(graph1) == True\n    assert check_bipartite(graph2) == True\n\ndef test_check_bipartite_false():\n    graph1 = {\n        'A': ['B', 'C'],\n        'B': ['A', 'C', 'D'],\n        'C': ['A', 'B', 'D'],\n        'D': ['B', 'C']\n    }\n\n    graph2 = {\n        'A': ['B'],\n        'B': ['A', 'C'],\n        'C': ['B', 'D'],\n        'D': ['C', 'E'],\n        'E': ['D']\n    }\n\n    assert check_bipartite(graph1) == False\n    assert check_bipartite(graph2) == False\n```\nMake sure to save the implementation code in a file called `bipartite_graph.py` and the tests in a file called `test_bipartite_graph.py`. To run the tests, simply execute `pytest` in your command line."}, {"key": "ConceptualPromptV2_39", "prompt": "Write Python code to compute the speed of sound in a medium, given its bulk modulus and density. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code to compute the speed of sound in a medium:\n\n```python\nimport math\n\ndef compute_speed_of_sound(bulk_modulus, density):\n    \"\"\"\n    Compute the speed of sound in a medium.\n    \n    Args:\n        bulk_modulus (float): The bulk modulus of the medium (in Pa).\n        density (float): The density of the medium (in kg/m^3).\n        \n    Returns:\n        float: The speed of sound in the medium (in m/s).\n    \"\"\"\n    return math.sqrt(bulk_modulus / density)\n\n# Example: Compute the speed of sound in water\n# Bulk modulus of water: 2.15e9 Pa (at 20 \u00b0C)\n# Density of water: 1000 kg/m\u00b3 (at 20 \u00b0C)\nwater_bulk_modulus = 2.15e9\nwater_density = 1000\nspeed_of_sound_water = compute_speed_of_sound(water_bulk_modulus, water_density)\nprint(f\"Speed of sound in water: {speed_of_sound_water:.2f} m/s\")\n```\n\nHere is a set of pytest tests for the `compute_speed_of_sound` function:\n\n```python\nimport pytest\nfrom speed_of_sound import compute_speed_of_sound\n\ndef test_compute_speed_of_sound():\n    # Test with known values for water\n    water_bulk_modulus = 2.15e9\n    water_density = 1000\n    speed_of_sound_water = compute_speed_of_sound(water_bulk_modulus, water_density)\n    assert pytest.approx(1463.14, abs=1e-2) == speed_of_sound_water\n\n    # Test with known values for air\n    air_bulk_modulus = 1.42e5\n    air_density = 1.225\n    speed_of_sound_air = compute_speed_of_sound(air_bulk_modulus, air_density)\n    assert pytest.approx(331.44, abs=1e-2) == speed_of_sound_air\n\n    # Test with custom values, speed should be greater than 0 unless bulk modulus or density is 0\n    custom_bulk_modulus = 5.0e8\n    custom_density = 1200\n    speed_of_sound_custom = compute_speed_of_sound(custom_bulk_modulus, custom_density)\n    assert speed_of_sound_custom > 0\n\n    # Test with 0 bulk modulus, speed should be 0\n    zero_bulk_modulus = 0\n    speed_of_sound_zero_bulk_modulus = compute_speed_of_sound(zero_bulk_modulus, custom_density)\n    assert speed_of_sound_zero_bulk_modulus == 0\n\n    # Test with 0 density, speed should be 0\n    zero_density = 0\n    speed_of_sound_zero_density = compute_speed_of_sound(custom_bulk_modulus, zero_density)\n    assert speed_of_sound_zero_density == 0\n```"}, {"key": "ConceptualPromptV2_47", "prompt": "Develop a Python code to compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the Euclidean algorithm for computing the GCD of two numbers:\n\n```python\ndef gcd(a: int, b: int) -> int:\n    \"\"\"\n    Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    :param a: First number\n    :param b: Second number\n    :return: GCD of a and b\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return abs(a)\n\n\nif __name__ == \"__main__\":\n    num1 = 56\n    num2 = 98\n    result = gcd(num1, num2)\n    print(f\"The GCD of {num1} and {num2} is {result}.\")\n```\n\nFor the pytest tests, you can use the following code:\n\n```python\nimport pytest\nfrom gcd_euclidean import gcd\n\ndef test_gcd():\n    assert gcd(56, 98) == 14\n    assert gcd(98, 56) == 14\n    assert gcd(42, 28) == 14\n    assert gcd(0, 5) == 5\n    assert gcd(5, 0) == 5\n    assert gcd(-14, 28) == 14\n    assert gcd(14, -28) == 14\n    assert gcd(-14, -28) == 14\n    assert gcd(0, 0) == 0\n```\n\nMake sure to save the initial implementation in a file named `gcd_euclidean.py` and the test file as `test_gcd_euclidean.py`. You can then run the tests with `pytest test_gcd_euclidean.py`."}, {"key": "ConceptualPromptV2_56", "prompt": "Write a Python function to compute the longest common subsequence of two given strings using dynamic programming. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python implementation of the longest common subsequence using dynamic programming:\n\n```python\ndef longest_common_subsequence(X: str, Y: str) -> str:\n    \"\"\"\n    Compute the longest common subsequence of two given strings using dynamic programming.\n\n    :param X: string X\n    :param Y: string Y\n    :return: longest common subsequence of X and Y\n    \"\"\"\n    m = len(X)\n    n = len(Y)\n\n    # Create a table to store lengths of longest common suffixes of substrings\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill L[m][n] in bottom-up fashion\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # Reconstruct the LCS from the L table\n    result = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        if X[i - 1] == Y[j - 1]:\n            result = X[i - 1] + result\n            i -= 1\n            j -= 1\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return result\n```\n\nAnd here are some pytest tests for the function:\n\n```python\nimport pytest\nfrom lcs import longest_common_subsequence\n\n\n@pytest.mark.parametrize(\"X,Y,result\", [\n    (\"\", \"\", \"\"),\n    (\"ABCDGH\", \"AEDFHR\", \"ADH\"),\n    (\"AGGTAB\", \"GXTXAYB\", \"GTAB\"),\n    (\"abcdefghijklm\", \"nopqrstuvwxyz\", \"\"),\n    (\"ANALYSIS\", \"SYSTEM\", \"SYS\")\n])\ndef test_longest_common_subsequence(X, Y, result):\n    assert longest_common_subsequence(X, Y) == result\n```"}, {"key": "ConceptualPromptV2_2", "prompt": "Create Python code to perform K-means clustering on a given dataset. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code for K-means clustering:\n\n```python\nimport numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets import make_blobs\n\n# Create a sample dataset\ndef create_sample_data(n_samples=300, n_features=2, centers=3, random_state=None):\n    X, y = make_blobs(n_samples=n_samples, n_features=n_features, centers=centers, random_state=random_state)\n    return X, y\n\n# Apply K-means clustering on the dataset\ndef k_means_clustering(X, n_clusters=3, init='k-means++', max_iter=300, n_init=10, random_state=None):\n    kmeans = KMeans(n_clusters=n_clusters, init=init, max_iter=max_iter, n_init=n_init, random_state=random_state)\n    kmeans.fit(X)\n    return kmeans\n\n# Cluster predictions for the dataset\ndef predict_clusters(kmeans, X):\n    return kmeans.predict(X)\n\n# Example usage\nif __name__ == \"__main__\":\n    X, y = create_sample_data(random_state=42)\n    kmeans = k_means_clustering(X, n_clusters=3, random_state=42)\n    cluster_predictions = predict_clusters(kmeans, X)\n    print(\"Cluster predictions:\\n\", cluster_predictions)\n```\n\nNow, for the pytest tests:\n\n```python\nimport pytest\nfrom my_kmeans_module import create_sample_data, k_means_clustering, predict_clusters\n\ndef test_create_sample_data():\n    X, y = create_sample_data(n_samples=10, n_features=2, centers=2, random_state=42)\n    assert X.shape == (10, 2)\n    assert y.shape == (10,)\n\ndef test_k_means_clustering():\n    X, y = create_sample_data(n_samples=10, n_features=2, centers=2, random_state=42)\n    kmeans = k_means_clustering(X, n_clusters=2, random_state=42)\n    assert kmeans is not None\n\ndef test_predict_clusters():\n    X, y = create_sample_data(n_samples=10, n_features=2, centers=2, random_state=42)\n    kmeans = k_means_clustering(X, n_clusters=2, random_state=42)\n    cluster_predictions = predict_clusters(kmeans, X)\n    assert cluster_predictions.shape == (10,)\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n```\n\nIn order to run the tests, make sure to save the first code block in a file called `my_kmeans_module.py` and the second code block in a file called `test_my_kmeans_module.py`. Then, simply execute `pytest test_my_kmeans_module.py` in your terminal to run the tests."}, {"key": "ConceptualPromptV2_69", "prompt": "Create a Python function to calculate the net primary productivity of an ecosystem, given the rates of gross primary productivity and respiration. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python function to calculate the net primary productivity (NPP) of an ecosystem, given the rates of gross primary productivity (GPP) and respiration (R):\n\n```python\ndef net_primary_productivity(gpp, respiration):\n    \"\"\"\n    Calculate the net primary productivity (NPP) of an ecosystem.\n\n    Args:\n    gpp (float): The rate of gross primary productivity.\n    respiration (float): The rate of respiration.\n\n    Returns:\n    float: The net primary productivity (NPP) of the ecosystem.\n    \"\"\"\n\n    npp = gpp - respiration\n    return npp\n\n# Example usage:\ngpp_example = 2500  # Example value for gross primary productivity\nrespiration_example = 1500  # Example value for respiration\n\nnpp_example = net_primary_productivity(gpp_example, respiration_example)\nprint(npp_example)\n```\n\nHere's a set of pytest tests that exercise the `net_primary_productivity` function:\n\n```python\nimport pytest\n\nfrom npp_calculator import net_primary_productivity  # Your .py file should be named as 'npp_calculator.py'\n\n\ndef test_net_primary_productivity_positive():\n    gpp = 2500\n    respiration = 1500\n    expected_npp = 1000\n    assert net_primary_productivity(gpp, respiration) == expected_npp\n\n\ndef test_net_primary_productivity_zero():\n    gpp = 1500\n    respiration = 1500\n    expected_npp = 0\n    assert net_primary_productivity(gpp, respiration) == expected_npp\n\n\ndef test_net_primary_productivity_negative():\n    gpp = 1000\n    respiration = 1500\n    expected_npp = -500\n    assert net_primary_productivity(gpp, respiration) == expected_npp\n```\n\nTo execute the tests, make sure you have pytest installed (`pip install pytest`), then run `pytest` in your terminal, followed by the name of the .py file containing the tests."}, {"key": "ConceptualPromptV2_48", "prompt": "Write a Python function to generate a Fibonacci sequence using a recursive approach. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to generate a Fibonacci sequence using a recursive approach:\n\n```python\ndef fibonacci_recursive(n):\n    \"\"\"\n    Generate the nth value in the Fibonacci sequence using a recursive approach.\n    \n    Args:\n    n (int): The position of the desired value in the Fibonacci sequence.\n\n    Returns:\n    int: The nth value in the Fibonacci sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Fibonacci sequence is defined for positive integers\")\n    \n    if n == 1 or n == 2:\n        return 1\n\n    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n```\n\nHere is a set of pytest tests that exercise the `fibonacci_recursive` function:\n\n```python\nimport pytest\nfrom fibonacci import fibonacci_recursive\n\ndef test_fibonacci_recursive_base_cases():\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(2) == 1\n\ndef test_fibonacci_recursive_positive_cases():\n    assert fibonacci_recursive(3) == 2\n    assert fibonacci_recursive(4) == 3\n    assert fibonacci_recursive(5) == 5\n    assert fibonacci_recursive(6) == 8\n\ndef test_fibonacci_recursive_negative_case():\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n\ndef test_fibonacci_recursive_zero_case():\n    with pytest.raises(ValueError):\n        fibonacci_recursive(0)\n```\n\nSave the first code block content in a file named `fibonacci.py` and the tests into a file named `test_fibonacci.py`. Run pytest with the command `pytest test_fibonacci.py`."}, {"key": "ConceptualPromptV2_46", "prompt": "Write a Python program to implement the quicksort algorithm for sorting a list of numbers. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python program that implements the quicksort algorithm for sorting a list of numbers:\n\n```python\ndef quicksort(arr):\n    # base case\n    if len(arr) <= 1:\n        return arr\n\n    # choose pivot\n    pivot = arr[len(arr) // 2]\n\n    # partition array into 3 parts: elements <= pivot, pivot itself, elements >= pivot\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n\n    # recursively sort left and right parts and combine them together with the middle part\n    return quicksort(left) + middle + quicksort(right)\n\n# Example usage:\nexample_arr = [3, 6, 8, 10, 1, 2, 1]\nprint(\"Original Array:\", example_arr)\nprint(\"Sorted Array:\", quicksort(example_arr))\n```\n\nHere is a simple pytest test suite that exercises the `quicksort` function:\n\n```python\nimport pytest\nfrom quicksort import quicksort\n\ndef test_quicksort_empty():\n    assert quicksort([]) == []\n\ndef test_quicksort_single_element():\n    assert quicksort([8]) == [8]\n\ndef test_quicksort_sorted_array():\n    assert quicksort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_quicksort_reverse_sorted_array():\n    assert quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_quicksort_negative_numbers():\n    assert quicksort([3, -1, 5, 0, -5, -2]) == [-5, -2, -1, 0, 3, 5]\n\ndef test_quicksort_duplicates():\n    assert quicksort([4, 5, 2, 2, 4, 1, 5]) == [1, 2, 2, 4, 4, 5, 5]\n ```\n \nFor running the tests, save the quicksort implementation in a file called `quicksort.py`, and the tests in a file called `test_quicksort.py`. After that, execute the command `pytest` in your terminal."}, {"key": "ConceptualPromptV2_81", "prompt": "Create a Python function to model the supply and demand curves of a market, given the price elasticity of supply and demand, and the equilibrium price and quantity. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to model the supply and demand curves of a market:\n\n```python\nimport numpy as np\n\ndef supply_demand_model(price_elasticity_of_supply, price_elasticity_of_demand, equilibrium_price, equilibrium_quantity):\n    \"\"\"\n    Function to model the supply and demand curves of a market.\n\n    Args:\n    price_elasticity_of_supply (float): The price elasticity of supply.\n    price_elasticity_of_demand (float): The price elasticity of demand.\n    equilibrium_price (float): The equilibrium price of the market.\n    equilibrium_quantity (float): The equilibrium quantity of the market.\n\n    Returns:\n    tuple: A tuple containing the supply and demand curve functions.\n    \"\"\"\n\n    def supply_curve(price):\n        return equilibrium_quantity * (price / equilibrium_price) ** price_elasticity_of_supply\n\n    def demand_curve(price):\n        return equilibrium_quantity * (price / equilibrium_price) ** -price_elasticity_of_demand\n\n    return supply_curve, demand_curve\n\n# Example values\nprice_elasticity_of_supply = 1.5\nprice_elasticity_of_demand = 0.7\nequilibrium_price = 100\nequilibrium_quantity = 500\n\nsupply_curve, demand_curve = supply_demand_model(price_elasticity_of_supply, price_elasticity_of_demand, equilibrium_price, equilibrium_quantity)\n\nprices = np.linspace(1, 200, 100)\nsupply_values = [supply_curve(price) for price in prices]\ndemand_values = [demand_curve(price) for price in prices]\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom supply_demand import supply_demand_model\n\n@pytest.fixture\ndef example_curves():\n    price_elasticity_of_supply = 1.5\n    price_elasticity_of_demand = 0.7\n    equilibrium_price = 100\n    equilibrium_quantity = 500\n    supply_curve, demand_curve = supply_demand_model(price_elasticity_of_supply, price_elasticity_of_demand, equilibrium_price, equilibrium_quantity)\n    return supply_curve, demand_curve, equilibrium_price, equilibrium_quantity\n\ndef test_supply_curve(example_curves):\n    supply_curve, _, equilibrium_price, equilibrium_quantity = example_curves\n    assert supply_curve(equilibrium_price) == equilibrium_quantity\n    assert supply_curve(equilibrium_price * 2) > equilibrium_quantity\n\ndef test_demand_curve(example_curves):\n    _, demand_curve, equilibrium_price, equilibrium_quantity = example_curves\n    assert demand_curve(equilibrium_price) == equilibrium_quantity\n    assert demand_curve(equilibrium_price * 0.5) > equilibrium_quantity\n\ndef test_supply_demand_equilibrium(example_curves):\n    supply_curve, demand_curve, equilibrium_price, equilibrium_quantity = example_curves\n    assert supply_curve(equilibrium_price) == demand_curve(equilibrium_price)\n    assert supply_curve(equilibrium_price) == equilibrium_quantity\n```"}, {"key": "ConceptualPromptV2_76", "prompt": "Write a Python code to model the succession of plant communities in an ecosystem, given the growth rates, competitive abilities, and disturbance rates of different species. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python code that models the succession of plant communities in an ecosystem:\n\n```python\nimport random\n\nclass Plant:\n    def __init__(self, growth_rate, competitive_ability, disturbance_rate):\n        self.growth_rate = growth_rate\n        self.competitive_ability = competitive_ability\n        self.disturbance_rate = disturbance_rate\n\ndef simulate_succession(plants, years):\n    \"\"\"Simulates the succession of plant communities over a specified number of years.\"\"\"\n    for year in range(years):\n        update_growth_rates(plants)\n        apply_competition(plants)\n        apply_disturbance(plants)\n    return plants\n\ndef update_growth_rates(plants):\n    \"\"\"Updates the growth rates of plants based on their competitive abilities.\"\"\"\n    for plant in plants:\n        plant.growth_rate += plant.competitive_ability\n\ndef apply_competition(plants):\n    \"\"\"Simulates competition between plants by scaling their growth rates.\"\"\"\n    total_growth_rate = sum([plant.growth_rate for plant in plants])\n    for plant in plants:\n        plant.growth_rate = plant.growth_rate / total_growth_rate\n        \ndef apply_disturbance(plants):\n    \"\"\"Apply a random disturbance to the plants and update their growth rates.\"\"\"\n    for plant in plants:\n        disturbance = random.uniform(0.5, 1.5)\n        plant.growth_rate *= (1 - plant.disturbance_rate * disturbance)\n\n# Example plants\nplant_a = Plant(growth_rate=1, competitive_ability=0.3, disturbance_rate=0.2)\nplant_b = Plant(growth_rate=1.5, competitive_ability=0.5, disturbance_rate=0.3)\nplant_c = Plant(growth_rate=2, competitive_ability=0.1, disturbance_rate=0.1)\n\nplants = [plant_a, plant_b, plant_c]\n\n# Run the simulation\nresult = simulate_succession(plants, 20)\nfor i, plant in enumerate(result):\n    print(f\"Plant {i + 1} growth rate: {plant.growth_rate}\")\n```\n\nHere is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom succession import Plant, update_growth_rates, apply_competition, apply_disturbance\n\ndef test_update_growth_rates():\n    plant_a = Plant(1, 0.3, 0.2)\n    plant_b = Plant(1.5, 0.5, 0.3)\n    plants = [plant_a, plant_b]\n\n    update_growth_rates(plants)\n\n    assert plants[0].growth_rate == pytest.approx(1.3)\n    assert plants[1].growth_rate == pytest.approx(2.0)\n\ndef test_apply_competition():\n    plant_a = Plant(1, 0.3, 0.2)\n    plant_b = Plant(1.5, 0.5, 0.3)\n    plants = [plant_a, plant_b]\n\n    apply_competition(plants)\n\n    assert plants[0].growth_rate == pytest.approx(0.4)\n    assert plants[1].growth_rate == pytest.approx(0.6)\n\ndef test_apply_disturbance():\n    plant_a = Plant(1, 0.3, 0.2)\n    plant_b = Plant(1.5, 0.5, 0.3)\n    plants = [plant_a, plant_b]\n\n    random.seed(42)  # Setting seed for deterministic test results\n    apply_disturbance(plants)\n\n    assert plants[0].growth_rate == pytest.approx(0.78200000000)\n    assert plants[1].growth_rate == pytest.approx(1.10600000000)\n```"}, {"key": "ConceptualPromptV2_50", "prompt": "Write a Python program to implement the Ford-Fulkerson algorithm for solving the maximum flow problem in a network. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the Ford-Fulkerson algorithm for solving the maximum flow problem in a network:\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(lambda: defaultdict(int))\n\n    def add_edge(self, u, v, w):\n        self.graph[u][v] = w\n\n    def bfs(self, src, dest, parent):\n        visited = [False] * self.V\n        queue = [src]\n        visited[src] = True\n\n        while queue:\n            u = queue.pop(0)\n\n            for v, w in self.graph[u].items():\n                if not visited[v] and w > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n\n                    if v == dest:\n                        return True\n        return False\n\n    def max_flow(self, src, dest):\n        parent = [-1] * self.V\n        max_flow = 0\n\n        while self.bfs(src, dest, parent):\n            path_flow = float(\"Inf\")\n            v = dest\n\n            while v != src:\n                u = parent[v]\n                path_flow = min(path_flow, self.graph[u][v])\n                v = u\n\n            max_flow += path_flow\n\n            v = dest\n            while v != src:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = u\n\n        return max_flow\n\ndef main():\n    g = Graph(6)\n    g.add_edge(0, 1, 16)\n    g.add_edge(0, 2, 13)\n    g.add_edge(1, 3, 12)\n    g.add_edge(2, 1, 4)\n    g.add_edge(2, 4, 14)\n    g.add_edge(3, 2, 9)\n    g.add_edge(3, 5, 20)\n    g.add_edge(4, 3, 7)\n    g.add_edge(4, 5, 4)\n\n    source = 0\n    sink = 5\n\n    print(f\"The maximum possible flow is {g.max_flow(source, sink)}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nHere's a set of `pytest` tests that exercise each of the functions:\n\n```python\nfrom ford_fulkerson import Graph\nimport pytest\n\ndef test_graph_initialization():\n    g = Graph(4)\n    assert g.V == 4\n    assert g.graph == defaultdict(lambda: defaultdict(int))\n\ndef test_graph_add_edge():\n    g = Graph(4)\n    g.add_edge(0, 1, 10)\n    g.add_edge(1, 2, 5)\n    assert g.graph[0][1] == 10\n    assert g.graph[1][2] == 5\n\ndef test_graph_bfs():\n    g = Graph(4)\n    g.add_edge(0, 1, 5)\n    g.add_edge(1, 3, 8)\n    g.add_edge(0, 2, 7)\n    g.add_edge(2, 3, 12)\n\n    parent = [-1] * 4\n    assert g.bfs(0, 3, parent) == True\n\ndef test_max_flow():\n    g = Graph(4)\n    g.add_edge(0, 1, 5)\n    g.add_edge(1, 3, 8)\n    g.add_edge(0, 2, 7)\n    g.add_edge(2, 3, 12)\n\n    max_flow = g.max_flow(0, 3)\n    assert max_flow == 12\n```"}, {"key": "ConceptualPromptV2_53", "prompt": "Create a Python function to implement the backtracking algorithm for solving the N-queens problem. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "I will provide you with a Python function that implements the backtracking algorithm for solving the N-queens problem. Here's the code block for the main implementation:\n\n```python\ndef is_safe(board, row, col, n):\n    # Check in the current row\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n\n    # Check upper diagonal\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n\n    # Check lower diagonal\n    for i, j in zip(range(row, n, 1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n\n    return True\n\n\ndef n_queens_helper(board, col, n):\n    if col >= n:\n        return True\n\n    for row in range(n):\n        if is_safe(board, row, col, n):\n            board[row][col] = 1\n\n            if n_queens_helper(board, col + 1, n):\n                return True\n\n            board[row][col] = 0\n\n    return False\n\n\ndef n_queens(n):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n\n    if not n_queens_helper(board, 0, n):\n        return \"Solution does not exist\"\n\n    return board\n```\n\nHere's the code block for the pytest test cases:\n\n```python\nimport pytest\nfrom n_queens import n_queens, is_safe, n_queens_helper\n\ndef test_is_safe():\n    board = [\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [0, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    assert is_safe(board, 2, 2, 4) == False\n    assert is_safe(board, 3, 3, 4) == False\n    assert is_safe(board, 1, 1, 4) == False\n    assert is_safe(board, 0, 0, 4) == True\n\ndef test_n_queens_helper():\n    board = [\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    assert n_queens_helper(board, 0, 4) == True\n    assert n_queens_helper(board, 1, 4) == False\n\ndef test_n_queens():\n    result = n_queens(4)\n    expected = [\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [0, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    assert result == expected\n\n    result = n_queens(3)\n    assert result == \"Solution does not exist\"\n```\n\nMake sure to save the main implementation in a file called `n_queens.py` and the test cases in a file called `test_n_queens.py`. To run the tests, you'll need to have pytest installed, and then you can execute `pytest test_n_queens.py` in your terminal."}, {"key": "ConceptualPromptV2_3", "prompt": "Write a Python function to calculate the Pearson correlation coefficient between two variables. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to calculate the Pearson correlation coefficient between two variables:\n\n```python\nimport numpy as np\n\ndef pearson_correlation(x, y):\n    \"\"\"\n    Calculate the Pearson correlation coefficient between two variables.\n    \n    :param x: List of values of the first variable\n    :param y: List of values of the second variable\n    :return: Pearson correlation coefficient\n    \"\"\"\n    if len(x) != len(y):\n        raise ValueError(\"Both lists should have the same length\")\n\n    mean_x = np.mean(x)\n    mean_y = np.mean(y)\n\n    num = np.sum((np.array(x) - mean_x) * (np.array(y) - mean_y))\n    den = np.sqrt(np.sum((np.array(x) - mean_x) ** 2) * np.sum((np.array(y) - mean_y) ** 2))\n\n    if den == 0:\n        raise ValueError(\"Pearson correlation is not defined when the denominator is zero\")\n\n    correlation = num / den\n    return correlation\n```\n\nHere is a set of pytest tests that exercise the above function:\n\n```python\nimport pytest\nfrom pearson_correlation import pearson_correlation\n\ndef test_positive_correlation():\n    x = [1, 2, 3, 4, 5]\n    y = [2, 4, 6, 8, 10]\n    assert pearson_correlation(x, y) == 1\n\n\ndef test_negative_correlation():\n    x = [1, 2, 3, 4, 5]\n    y = [10, 8, 6, 4, 2]\n    assert pearson_correlation(x, y) == -1\n\n\ndef test_no_correlation():\n    x = [1, 2, 3, 4, 5]\n    y = [5, 2, 1, 8, 10]\n    assert round(pearson_correlation(x, y), 2) == 0.24\n\n\ndef test_unequal_lengths():\n    x = [1, 2, 3, 4, 5]\n    y = [2, 4, 6]\n    with pytest.raises(ValueError):\n        pearson_correlation(x, y)\n\n\ndef test_zero_denominator():\n    x = [1, 1, 1, 1, 1]\n    y = [2, 2, 2, 2, 2]\n    with pytest.raises(ValueError):\n        pearson_correlation(x, y)\n```\n\nBefore running the tests, make sure to save the function in a file named `pearson_correlation.py` and the tests in a file named `test_pearson_correlation.py`. You can then run the tests using the `pytest` command."}, {"key": "ConceptualPromptV2_67", "prompt": "Develop a Python function to estimate the ecological footprint of human activities, given the consumption rates of resources and the ecosystem's biocapacity. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python function to estimate the ecological footprint of human activities along with comments to explain each part of the code:\n\n```python\ndef ecological_footprint(consumption_rates, biocapacity):\n    \"\"\"\n    Estimate the ecological footprint of human activities.\n\n    Args:\n    consumption_rates (dict): A dictionary containing the consumption rates of resources. \n                              Key: resource type; Value: consumption rate in global hectares (gha) per capita\n    biocapacity (float): The ecosystem's biocapacity in global hectares (gha) per capita\n\n    Returns:\n    float: The estimated ecological footprint in global hectares (gha) per capita\n    \"\"\"\n    # Calculate the sum of the consumption rates for all resources\n    total_consumption = sum(consumption_rates.values())\n\n    # Calculate the ecological footprint by subtracting the biocapacity from the total consumption\n    ecological_footprint = total_consumption - biocapacity\n\n    return ecological_footprint\n```\n\nHere's an example of how you might use the function:\n\n```python\nconsumption_rates_example = {\n    'cropland': 0.8,\n    'grazing_land': 0.4,\n    'forest_land': 0.6,\n    'fishing_ground': 0.3,\n    'built_up_land': 0.4,\n    'carbon': 1.5\n}\n\nbiocapacity_example = 1.8\n\nresult = ecological_footprint(consumption_rates_example, biocapacity_example)\nprint(result)  # Output: 1.2\n```\n\nNext, here's a set of pytest tests that exercise the `ecological_footprint` function:\n\n```python\nimport pytest\nfrom ecological_footprint_calculator import ecological_footprint\n\ndef test_positive_ecological_footprint():\n    consumption_rates = {'cropland': 0.5, 'forest_land': 0.7, 'carbon': 1.7}\n    biocapacity = 2.5\n    assert ecological_footprint(consumption_rates, biocapacity) == 0.4\n\ndef test_negative_ecological_footprint():\n    consumption_rates = {'cropland': 0.8, 'grazing_land': 0.4, 'fishing_ground': 0.3}\n    biocapacity = 2.0\n    assert ecological_footprint(consumption_rates, biocapacity) == -0.5\n\ndef test_zero_ecological_footprint():\n    consumption_rates = {'carbon': 1.0, 'built_up_land': 0.5}\n    biocapacity = 1.5\n    assert ecological_footprint(consumption_rates, biocapacity) == 0.0\n\ndef test_empty_consumption_rates():\n    consumption_rates = {}\n    biocapacity = 2.0\n    assert ecological_footprint(consumption_rates, biocapacity) == -2.0\n```"}, {"key": "ConceptualPromptV2_24", "prompt": "Write a Python function to compute the work done by a force on an object, given the force, the distance over which it is applied, and the angle between the force and the displacement. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to compute the work done by a force on an object:\n\n```python\nimport math\n\ndef work_done(force, distance, angle):\n    \"\"\"\n    Calculate work done based on the given force, distance, and angle.\n    \n    Args:\n    force (float): The force applied on the object (in Newtons).\n    distance (float): The distance the object is displaced (in meters).\n    angle (float): The angle between the force and displacement (in degrees).\n\n    Returns:\n    float: work done in Joules.\n    \"\"\"\n    # Convert angle from degrees to radians\n    angle_rad = math.radians(angle)\n\n    # Calculate work done\n    work = force * distance * math.cos(angle_rad)\n\n    return work\n```\n\nNow, here is a set of pytest tests to exercise the function:\n\n```python\nimport pytest\nfrom work_done_module import work_done\n\ndef test_work_done():\n    assert work_done(50, 10, 0) == 500\n    assert work_done(0, 10, 45) == 0\n    assert work_done(50, 0, 45) == 0\n    assert work_done(50, 10, 45) == pytest.approx(353.55, 0.01)\n    assert work_done(50, 10, 90) == 0\n```\n\nSave the function in a module named `work_done_module.py` and the tests in a file named `test_work_done.py`. To run the tests, install pytest (`pip install pytest`) and run `pytest test_work_done.py` in your terminal."}, {"key": "ConceptualPromptV2_91", "prompt": "Develop a Python code to calculate the Lorenz curve for a given distribution of income or wealth. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to calculate the Lorenz curve for a given distribution of income or wealth:\n\n```python\nimport numpy as np\n\ndef calculate_lorenz_curve(data):\n    \"\"\"\n    Function to calculate the Lorenz curve for a given distribution.\n\n    Parameters:\n    - data: List of values representing the income or wealth distribution\n\n    Returns:\n    - x_values: numpy.array, Cumulative percentages of the population\n    - y_values: numpy.array, Cumulative percentages of the income or wealth\n    \"\"\"\n    sorted_data = np.sort(data)\n    cum_data = np.cumsum(sorted_data)\n    total_data_sum = cum_data[-1]\n\n    x_values = np.arange(1, len(data) + 1) / len(data)\n    y_values = cum_data / total_data_sum\n\n    return x_values, y_values\n\n# Example usage:\ndata = [20_000, 25_000, 48_000, 50_000, 75_000, 80_000, 90_000, 100_000, 120_000, 150_000]\nx_values, y_values = calculate_lorenz_curve(data)\nprint(x_values, y_values)\n```\n\nNow, here's a separate code block that contains pytest tests for the above code:\n\n```python\nimport pytest\nimport numpy as np\nfrom lorenz_curve import calculate_lorenz_curve\n\ndef test_lorenz_curve():\n    data = [10, 20, 30, 40, 50]\n    expected_x_values = np.array([0.2, 0.4, 0.6, 0.8, 1.0])\n    expected_y_values = np.array([0.04, 0.12, 0.24, 0.44, 1.0])\n\n    x_values, y_values = calculate_lorenz_curve(data)\n\n    np.testing.assert_almost_equal(x_values, expected_x_values)\n    np.testing.assert_almost_equal(y_values, expected_y_values)\n\ndef test_negative_values():\n    with pytest.raises(ValueError):\n        data = [10, -20, 30, 40, 50]\n        x_values, y_values = calculate_lorenz_curve(data)\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\n\nMake sure to save the Lorenz curve code in a file named `lorenz_curve.py` and the pytest code in a file named `test_lorenz_curve.py`. You can then execute the tests with the `pytest` command.\n\n*Note: Install pytest by running `pip install pytest` if you don't have it installed already."}, {"key": "ConceptualPromptV2_77", "prompt": "Create a Python function to estimate the effective population size of a species, given its census population size, sex ratio, and variance in reproductive success. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python function to estimate the effective population size of a species, given its census population size, sex ratio, and variance in reproductive success:\n\n```python\ndef effective_population_size(census_population_size, sex_ratio, variance_reproductive_success):\n    \"\"\"\n    Estimates the effective population size based on the given parameters.\n\n    Parameters:\n    census_population_size (int): The census population size.\n    sex_ratio (float): The ratio of males to females in the population (e.g. 0.5 for an equal ratio).\n    variance_reproductive_success (float): The variance in reproductive success.\n\n    Returns:\n    int: The estimated effective population size.\n    \"\"\"\n    # Number of males\n    n_males = census_population_size * sex_ratio\n\n    # Number of females\n    n_females = census_population_size * (1 - sex_ratio)\n\n    # The number of genes transmitted effectively.\n    n_e = (4 * n_males * n_females) / (n_males + n_females + 2 * variance_reproductive_success)\n\n    return int(n_e)\n```\n\nHere is a set of pytest tests that exercise the `effective_population_size` function:\n\n```python\nimport pytest\nfrom effective_population_size import effective_population_size\n\n\ndef test_effective_population_size():\n    assert effective_population_size(1000, 0.5, 1) == 333\n    assert effective_population_size(5000, 0.6, 10) == 1063\n    assert effective_population_size(2000, 0.55, 2) == 546\n    assert effective_population_size(100, 0.4, 5) == 21\n\n@pytest.mark.parametrize(\"census_population_size, sex_ratio, variance_reproductive_success, expected\", [\n    (1000, 0.5, 1, 333),\n    (5000, 0.6, 10, 1063),\n    (2000, 0.55, 2, 546),\n    (100, 0.4, 5, 21),\n])\ndef test_effective_population_size_parametrized(census_population_size, sex_ratio, variance_reproductive_success, expected):\n    assert effective_population_size(census_population_size, sex_ratio, variance_reproductive_success) == expected\n```\nMake sure to save the function in a file named `effective_population_size.py`, and the tests in a separate file named `test_effective_population_size.py`. To execute the tests, simply run `pytest test_effective_population_size.py` in your terminal."}, {"key": "ConceptualPromptV2_88", "prompt": "Write a Python code to model the Cobb-Douglas production function, given the input quantities and their respective production elasticities. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code for modeling the Cobb-Douglas production function:\n\n```python\nimport math\n\ndef cobb_douglas(K, L, alpha, beta):\n    \"\"\"\n    Calculates the Cobb-Douglas production value given the input quantities and their respective production elasticities.\n    \n    Arguments:\n    K (float): quantity of capital input\n    L (float): quantity of labor input\n    alpha (float): capital's share of output (production elasticity)\n    beta (float): labor's share of output (production elasticity)\n\n    Returns:\n    (float): the calculated Cobb-Douglas production value\n    \"\"\"\n    return math.pow(K, alpha) * math.pow(L, beta)\n\nif __name__ == \"__main__\":\n    # Example values\n    K = 10\n    L = 20\n    alpha = 0.3\n    beta = 0.7\n\n    # Calculate the Cobb-Douglas production value with the given example values\n    result = cobb_douglas(K, L, alpha, beta)\n    print(\"Cobb-Douglas production value:\", result)\n```\n\nAnd, here are the pytest tests for the code:\n\n```python\nimport pytest\nfrom cobb_douglas import cobb_douglas\n\ndef test_cobb_douglas():\n    # Test case 1\n    assert round(cobb_douglas(10, 20, 0.3, 0.7), 6) == 14.142136\n\n    # Test case 2\n    assert round(cobb_douglas(30, 15, 0.4, 0.6), 6) == 376.274556\n\n    # Test case 3\n    assert round(cobb_douglas(5, 10, 0.5, 0.5), 6) == 22.627417\n\n    # Test case 4\n    assert round(cobb_douglas(40, 20, 0.8, 0.2), 6) == 1625.721724\n```"}, {"key": "ConceptualPromptV2_40", "prompt": "Write a Python code to implement Dijkstra's algorithm for finding the shortest path in a weighted graph. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of Dijkstra's algorithm for finding the shortest path in a weighted graph:\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    \"\"\"\n    Find the shortest path in a weighted, connected graph using Dijkstra's algorithm.\n\n    :param graph: A dictionary of adjacency lists. Example format:\n                  graph = {'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 3)], 'C': [('A', 4), ('B', 3)]}\n    :param start: The starting vertex.\n    :return: A tuple containing a dictionary of shortest path distances and a dictionary of predecessors.\n    \"\"\"\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    predecessors = {vertex: None for vertex in graph}\n\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                predecessors[neighbor] = current_vertex\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances, predecessors\n\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    Finds the shortest path between start and end vertices in a weighted, connected graph.\n\n    :param graph: A dictionary of adjacency lists. Example format:\n                  graph = {'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 3)], 'C': [('A', 4), ('B', 3)]}\n    :param start: The starting vertex.\n    :param end: The end vertex.\n    :return: A list of vertices in the shortest path, including the start and end vertices.\n    \"\"\"\n    distances, predecessors = dijkstra(graph, start)\n\n    path = [end]\n    while path[-1] != start:\n        path.append(predecessors[path[-1]])\n    path.reverse()\n\n    return path\n\ngraph = {\n    'A': [('B', 1), ('C', 4)],\n    'B': [('A', 1), ('C', 3), ('D', 5)],\n    'C': [('A', 4), ('B', 3), ('D', 2)],\n    'D': [('B', 5), ('C', 2)]\n}\n\nprint(shortest_path(graph, 'A', 'D'))  # Output: ['A', 'B', 'C', 'D']\n```\n\nHere are some pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom dijkstra import dijkstra, shortest_path\n\n@pytest.fixture\ndef sample_graph():\n    return {\n        'A': [('B', 1), ('C', 4)],\n        'B': [('A', 1), ('C', 3), ('D', 5)],\n        'C': [('A', 4), ('B', 3), ('D', 2)],\n        'D': [('B', 5), ('C', 2)]\n    }\n\ndef test_dijkstra(sample_graph):\n    distances, predecessors = dijkstra(sample_graph, 'A')\n    assert distances == {'A': 0, 'B': 1, 'C': 4, 'D': 6}\n    assert predecessors == {'A': None, 'B': 'A', 'C': 'B', 'D': 'C'}\n\ndef test_shortest_path(sample_graph):\n    assert shortest_path(sample_graph, 'A', 'D') == ['A', 'B', 'C', 'D']\n    assert shortest_path(sample_graph, 'B', 'A') == ['B', 'A']\n    assert shortest_path(sample_graph, 'A', 'C') == ['A', 'B', 'C']\n```"}, {"key": "ConceptualPromptV2_16", "prompt": "Generate Python code to compute the entropy of a probability distribution. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to compute the entropy of a probability distribution:\n\n```python\nimport math\n\ndef entropy(prob_dist):\n    \"\"\"\n    Compute the entropy of a probability distribution.\n\n    :param prob_dist: List of probabilities that represents the distribution.\n    :return: Entropy of the given probability distribution.\n    \"\"\"\n    return -sum(p * math.log2(p) for p in prob_dist if p > 0)\n\ndef main():\n    prob_dist = [0.5, 0.25, 0.25]\n    print(f\"Entropy of the given distribution: {entropy(prob_dist):.4f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nAnd here are some pytest tests for the function:\n\n```python\nimport pytest\nfrom entropy import entropy\n\ndef test_entropy_zeros():\n    prob_dist = [0, 0, 0]\n    assert entropy(prob_dist) == 0\n\ndef test_entropy_uniform():\n    prob_dist = [0.25, 0.25, 0.25, 0.25]\n    assert entropy(prob_dist) == 2\n\ndef test_entropy_binary():\n    prob_dist = [0.4, 0.6]\n    assert pytest.approx(entropy(prob_dist), 0.9709)\n\ndef test_entropy_invalid_distribution():\n    prob_dist = [0.2, 0.3, 0.6]\n    with pytest.raises(ValueError):\n        entropy(prob_dist)\n```\n\nPlease ensure that you have `pytest` installed in your Python environment. You can install it using `pip install pytest` if you don't have it already. To run the tests, save the code in separate files as `entropy.py` (for main code) and `test_entropy.py` (for tests) and run `pytest test_entropy.py`."}, {"key": "ConceptualPromptV2_32", "prompt": "Write a Python function to compute the buoyant force on an object submerged in a fluid, given the object's volume and the fluid's density. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to compute the buoyant force on an object submerged in a fluid:\n\n```python\ndef buoyant_force(volume, fluid_density):\n    \"\"\"\n    Calculate the buoyant force on an object, given its volume and fluid density.\n    \n    Args:\n    volume (float): The volume of the object (in cubic meters, m^3)\n    fluid_density (float): The density of the fluid (in kg/m^3)\n    \n    Returns:\n    float: Buoyant force on the object (in Newtons, N)\n    \"\"\"\n    gravity = 9.81  # acceleration due to gravity (in m/s^2)\n    force = volume * fluid_density * gravity\n    return force\n\n# Example usage:\nvolume = 0.1  # Object volume in m^3\nfluid_density = 1000  # Fluid density in kg/m^3 (for freshwater)\nresult = buoyant_force(volume, fluid_density)\nprint(f\"The buoyant force on the object is {result} N.\")\n```\n\nHere's a set of pytest tests that exercise the `buoyant_force` function:\n\n```python\nimport pytest\nfrom buoyancy import buoyant_force\n\ndef test_buoyant_force():\n    volume = 0.1  # 0.1 m^3\n    fluid_density = 1000  # kg/m^3 for freshwater\n    expected = 981  # Newtons\n    result = buoyant_force(volume, fluid_density)\n    assert result == pytest.approx(expected)\n\n    volume = 0.5  # 0.5 m^3\n    fluid_density = 1030  # kg/m^3 for seawater\n    expected = 5091.15  # Newtons\n    result = buoyant_force(volume, fluid_density)\n    assert result == pytest.approx(expected)\n\n    volume = 0  # 0 m^3\n    fluid_density = 1000  # kg/m^3 for freshwater\n    expected = 0  # Newtons\n    result = buoyant_force(volume, fluid_density)\n    assert result == pytest.approx(expected)\n```"}, {"key": "ConceptualPromptV2_49", "prompt": "Create a Python code to implement the binary search algorithm for searching a given element in a sorted list. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the binary search algorithm:\n\n```python\ndef binary_search(sorted_list, target):\n    \"\"\"\n    Implement binary search algorithm to search for target in sorted_list.\n\n    Args:\n    sorted_list (list of int): The sorted list in which to search for target.\n    target (int): The value to search for.\n\n    Returns:\n    int: The index where the target is found, -1 if not found.\n    \"\"\"\n    low, high = 0, len(sorted_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = sorted_list[mid]\n\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n\n# Sample usage\nsorted_list = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\ntarget = 13\nindex = binary_search(sorted_list, target)\nprint(f\"Index of {target} in sorted_list is: {index}\")  # Output: Index of 13 in sorted_list is: 6\n```\n\nHere's a set of pytest test cases for the binary search implementation:\n\n```python\nimport pytest\nfrom binary_search import binary_search\n\n\n# Test data\n@pytest.mark.parametrize(\"sorted_list, target, expected\", [\n    ([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 13, 6),\n    ([2, 4, 6, 8, 10, 12, 14, 16, 18, 20], 5, -1),\n    ([-12, -8, -6, -4, 0, 2, 6, 8, 15], 15, 8),\n    ([-25, -20, -15, -10, -5, 0, 5, 10, 15], -20, 1),\n    ([20, 50, 80, 90, 100, 110, 500, 900], 50, 1),\n])\n\n\ndef test_binary_search(sorted_list, target, expected):\n    assert binary_search(sorted_list, target) == expected\n```"}, {"key": "ConceptualPromptV2_14", "prompt": "Write Python code to perform a two-sample t-test to compare the means of two populations. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation for a two-sample t-test to compare the means of two populations:\n\n```python\nimport numpy as np\nimport scipy.stats\n\ndef t_test_two_samples(sample1, sample2, alpha=0.05):\n    \"\"\"\n    This function performs a two-sample t-test to compare the means of two populations.\n\n    Parameters:\n    - sample1: List or NumPy array of numeric values for the first population\n    - sample2: List or NumPy array of numeric values for the second population\n    - alpha (optional): The significance level, default is 0.05 (5%)\n    \n    Returns:\n    - t_stat: Computed t-statistic\n    - p_value: Computed p-value\n    - reject_null: True if null hypothesis is rejected (means are different), otherwise False\n    \"\"\"\n    # Compute t-statistic and two-tailed p-value using the Scipy library\n    t_stat, p_value = scipy.stats.ttest_ind(sample1, sample2)\n\n    # Determine if the null hypothesis should be rejected\n    reject_null = p_value < alpha\n\n    return t_stat, p_value, reject_null\n\n# Example usage with random samples\nnp.random.seed(42)  # set seed for reproducibility\nsample1 = np.random.normal(loc=50, scale=5, size=100)\nsample2 = np.random.normal(loc=53, scale=5, size=100)\n\nt_stat, p_value, reject_null = t_test_two_samples(sample1, sample2)\n\nprint(\"t-statistic:\", t_stat)\nprint(\"p-value:\", p_value)\nprint(\"Reject null hypothesis (means are different):\", reject_null)\n```\n\nAnd here are some pytest tests to exercise each function:\n\n```python\nimport pytest\nimport numpy as np\nfrom your_module import t_test_two_samples\n\ndef test_t_test_two_samples():\n    np.random.seed(42)  # set seed for reproducibility\n    sample1 = np.random.normal(loc=50, scale=5, size=100)\n    sample2 = np.random.normal(loc=53, scale=5, size=100)\n\n    t_stat, p_value, reject_null = t_test_two_samples(sample1, sample2)\n\n    assert round(t_stat, 2) == -4.18\n    assert round(p_value, 8) == 0.00005533\n    assert reject_null is True\n\n    # Same distribution\n    sample3 = np.random.normal(loc=50, scale=5, size=100)\n\n    t_stat, p_value, reject_null = t_test_two_samples(sample1, sample3)\n\n    assert p_value > 0.05\n    assert reject_null is False\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n```\n\nReplace `from your_module import t_test_two_samples` with the appropriate import according to your project structure."}, {"key": "ConceptualPromptV2_44", "prompt": "Write a Python code to perform a depth-first search traversal on a given graph. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of depth-first search (DFS) traversal on a given graph. The graph is represented using adjacency lists:\n\n```python\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = dict()\n        for vertex in vertices:\n            self.graph[vertex] = set()\n\n    def add_edge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def dfs(self, start_vertex, visited=set()):\n        visited.add(start_vertex)\n        print(start_vertex, end=' ')\n\n        for neighbor in self.graph[start_vertex]:\n            if neighbor not in visited:\n                self.dfs(neighbor, visited)\n\ndef main():\n    vertices = ['A', 'B', 'C', 'D', 'E', 'F']\n    graph = Graph(vertices)\n    graph.add_edge('A', 'B')\n    graph.add_edge('A', 'C')\n    graph.add_edge('B', 'D')\n    graph.add_edge('B', 'E')\n    graph.add_edge('C', 'F')\n\n    print(\"Depth-first search traversal for the given graph:\")\n    graph.dfs('A')\n\nif __name__ == '__main__':\n    main()\n```\n\nFollowing is a pytest test suite for the implementation:\n\n```python\nimport pytest\nfrom dfs import Graph\n\ndef test_graph_init():\n    graph = Graph(['A', 'B', 'C'])\n    assert graph.graph == {'A': set(), 'B': set(), 'C': set()}\n\ndef test_add_edge():\n    graph = Graph(['A', 'B', 'C'])\n    graph.add_edge('A', 'B')\n    graph.add_edge('B', 'C')\n    assert graph.graph == {'A': {'B'}, 'B': {'A', 'C'}, 'C': {'B'}}\n\ndef test_dfs(capsys):\n    graph = Graph(['A', 'B', 'C', 'D', 'E', 'F'])\n    graph.add_edge('A', 'B')\n    graph.add_edge('A', 'C')\n    graph.add_edge('B', 'D')\n    graph.add_edge('B', 'E')\n    graph.add_edge('C', 'F')\n\n    graph.dfs('A')\n    captured = capsys.readouterr()\n    assert captured.out == \"A B D E C F \"\n```\n\nSave the first code block as `dfs.py`, and the second code block, which tests the implementation, should be saved as `test_dfs.py`. To run the tests, simply run `pytest` in the terminal."}, {"key": "ConceptualPromptV2_29", "prompt": "Create a Python function to compute the wavelength of a photon, given its energy and Planck's constant. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python function to compute the wavelength of a photon, given its energy and Planck's constant:\n\n```python\nimport scipy.constants\n\ndef compute_wavelength(energy, plancks_constant=scipy.constants.Planck):\n    \"\"\"\n    Compute the wavelength of a photon given its energy and Plancks constant.\n\n    :param energy: The energy of the photon (in Joules).\n    :type energy: float\n    :param plancks_constant: The Planck's constant (default: scipy.constants.Planck)\n    :type plancks_constant: float\n    :return: The wavelength of the photon (in meters).\n    :rtype: float\n    \"\"\"\n    speed_of_light = scipy.constants.speed_of_light\n\n    wavelength = (plancks_constant * speed_of_light) / energy\n    return wavelength\n```\n\nHere is a set of pytest tests to exercise the `compute_wavelength` function:\n\n```python\nimport pytest\nimport scipy.constants\nfrom wavelength import compute_wavelength\n\ndef test_compute_wavelength_positive_energy():\n    energy = 4.135667696e-15  # Example energy value in Joules\n    computed_wavelength = compute_wavelength(energy)\n    expected_wavelength = 4.804351820101201e-07  # Expected wavelength in meters\n    assert pytest.approx(computed_wavelength) == expected_wavelength\n\ndef test_compute_wavelength_with_custom_plancks_constant():\n    energy = 4.135667696e-15  # Example energy value in Joules\n    custom_plancks_constant = 6.62607015e-34  # Example custom Planck's constant in Js\n    computed_wavelength = compute_wavelength(energy, custom_plancks_constant)\n    expected_wavelength = 4.804351820101201e-07  # Expected wavelength in meters\n    assert pytest.approx(computed_wavelength) == expected_wavelength\n\ndef test_compute_wavelength_invalid_energy():\n    energy = -4.135667696e-15  # Example invalid energy value (negative) in Joules\n    with pytest.raises(ValueError):\n        compute_wavelength(energy)\n```\n\nPlease save the code in separate files and run pytest from your terminal:\n- Save the first code block in a file named \"wavelength.py\"\n- Save the second code block in a file named \"test_wavelength.py\"\n- Run `pytest test_wavelength.py` in your terminal"}, {"key": "ConceptualPromptV2_22", "prompt": "Write a Python program to determine the period of a simple pendulum given its length and the acceleration due to gravity. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python program that calculates the period of a simple pendulum:\n\n```python\nimport math\n\ndef pendulum_period(length, gravity):\n    \"\"\"\n    Calculate the period of a simple pendulum.\n\n    Args:\n        length (float): Length of the pendulum in meters.\n        gravity (float): Acceleration due to gravity in m/s^2.\n\n    Returns:\n        float: The period of the pendulum in seconds.\n    \"\"\"\n    if length <= 0 or gravity <= 0:\n        raise ValueError(\"Length and gravity must be positive numbers.\")\n\n    period = 2 * math.pi * math.sqrt(length / gravity)\n    return period\n\nif __name__ == \"__main__\":\n    length = 1.0  # Length of the pendulum in meters\n    gravity = 9.81  # Acceleration due to gravity in m/s^2\n\n    period = pendulum_period(length, gravity)\n    print(f\"The period of the pendulum with length {length} m and gravity {gravity} m/s^2 is {period:.2f} seconds.\")\n```\n\nHere is a set of pytest tests to exercise each of the functions:\n\n```python\nimport pytest\nfrom pendulum_period import pendulum_period\n\ndef test_pendulum_period():\n    length = 1.0\n    gravity = 9.81\n\n    period = pendulum_period(length, gravity)\n    assert round(period, 2) == 2.01\n\ndef test_pendulum_period_with_zero_length():\n    with pytest.raises(ValueError):\n        pendulum_period(0, 9.81)\n\ndef test_pendulum_period_with_zero_gravity():\n    with pytest.raises(ValueError):\n        pendulum_period(1.0, 0)\n\nif __name__ == \"__main__\":\n    pytest.main()\n```"}, {"key": "ConceptualPromptV2_45", "prompt": "Create a Python function to implement the Knapsack problem using a dynamic programming approach. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the Knapsack problem using dynamic programming:\n\n```python\ndef knap_sack(max_weight, weights, values, item_count):\n    \"\"\"\n    A function to solve the Knapsack problem using dynamic programming.\n\n    Args:\n    max_weight (int): The maximum weight the knapsack can hold.\n    weights (list): A list of weights for each item.\n    values (list): A list of values for each item.\n    item_count (int): The number of items.\n\n    Returns:\n    int: The maximum value that can be obtained by selecting a subset of items.\n    \"\"\"\n\n    # Create a table to store the solution for subproblems\n    table = [[0 for _ in range(max_weight + 1)] for _ in range(item_count + 1)]\n\n    for i in range(item_count + 1):\n        for w in range(max_weight + 1):\n            if i == 0 or w == 0:\n                table[i][w] = 0\n            elif weights[i - 1] <= w:\n                table[i][w] = max(values[i - 1] + table[i - 1][w - weights[i - 1]], table[i - 1][w])\n            else:\n                table[i][w] = table[i - 1][w]\n\n    return table[item_count][max_weight]\n\n# Example usage:\nweights = [10, 20, 30]\nvalues = [60, 100, 120]\nmax_weight = 50\nitem_count = len(weights)\n\nprint(knap_sack(max_weight, weights, values, item_count))  # Output: 220\n```\n\nNow, let's create pytest tests that exercise the functions:\n\n```python\nimport pytest\nfrom knapsack import knap_sack\n\ndef test_knap_sack():\n    weights = [10, 20, 30]\n    values = [60, 100, 120]\n    max_weight = 50\n    item_count = len(weights)\n    assert knap_sack(max_weight, weights, values, item_count) == 220\n\n    weights = [5, 10, 15]\n    values = [20, 40, 60]\n    max_weight = 30\n    item_count = len(weights)\n    assert knap_sack(max_weight, weights, values, item_count) == 80\n\n    weights = [2, 2, 4, 5]\n    values = [3, 7, 2, 9]\n    max_weight = 10\n    item_count = len(weights)\n    assert knap_sack(max_weight, weights, values, item_count) == 19\n```\n\nHere, the first block of code is the implementation of the Knapsack problem using dynamic programming, while the second block of code consists of the pytest tests. Save the implementation in a file named `knapsack.py` and the tests in a file named `test_knapsack.py`, then run the tests using the command `pytest test_knapsack.py`."}, {"key": "ConceptualPromptV2_74", "prompt": "Write a Python program to simulate the dynamics of a metapopulation, given the local population sizes, colonization rates, and extinction rates. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python program to simulate the dynamics of a metapopulation, given the local population sizes, colonization rates, and extinction rates:\n\n```python\nimport random\n\ndef update_population(local_population, colonization_rate, extinction_rate):\n    # Update the population by adding colonizers and removing extinct populations\n    for i, population in enumerate(local_population):\n        colonized = random.random() < colonization_rate\n        extinct = random.random() < extinction_rate\n\n        if colonized:\n            local_population[i] += 1\n        if extinct and local_population[i] > 0:\n            local_population[i] -= 1\n\n    return local_population\n\ndef simulate_metapopulation(iterations, local_population, colonization_rate, extinction_rate):\n    # Simulate the dynamics of a metapopulation for a given number of iterations\n    for _ in range(iterations):\n        local_population = update_population(local_population, colonization_rate, extinction_rate)\n\n    return local_population\n\n# Example parameters\niterations = 100\nlocal_population = [10, 5, 8, 12, 15, 20, 25, 30]\ncolonization_rate = 0.1\nextinction_rate = 0.05\n\n# Perform the simulation\nfinal_local_population = simulate_metapopulation(iterations, local_population, colonization_rate, extinction_rate)\nprint(final_local_population)\n```\n\nHere is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom metapopulation import update_population, simulate_metapopulation\n\ndef test_update_population():\n    local_population = [10, 5, 8, 12, 15, 20, 25, 30]\n    colonization_rate = 0.1\n    extinction_rate = 0.05\n\n    updated_population = update_population(local_population, colonization_rate, extinction_rate)\n\n    assert isinstance(updated_population, list)\n    assert len(updated_population) == len(local_population)\n    assert all(isinstance(pop, int) for pop in updated_population)\n\ndef test_simulate_metapopulation():\n    iterations = 100\n    local_population = [10, 5, 8, 12, 15, 20, 25, 30]\n    colonization_rate = 0.1\n    extinction_rate = 0.05\n\n    final_local_population = simulate_metapopulation(iterations, local_population, colonization_rate, extinction_rate)\n\n    assert isinstance(final_local_population, list)\n    assert len(final_local_population) == len(local_population)\n    assert all(isinstance(pop, int) for pop in final_local_population)\n\nif __name__ == \"__main__\":\n    pytest.main()\n```"}, {"key": "ConceptualPromptV2_64", "prompt": "Write a Python function to analyze the impact of habitat fragmentation on species populations, given the size of the habitat patches and the species-area relationship. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to analyze the impact of habitat fragmentation on species populations:\n\n```python\nimport math\n\ndef habitat_size_to_species(area, z, c):\n    \"\"\"\n    Calculates the number of species present in a habitat patch\n    using the species-area relationship (SAR).\n\n    SAR = c * A ** z\n\n    :param area: float, size of the habitat patch (A)\n    :param z: float, coefficient for the power-law relationship\n    :param c: float, proportional constant in the species-area relationship\n    :return: float, number of species (S)\n    \"\"\"\n    return c * (area ** z)\n\n\ndef total_species(habitat_sizes, z, c):\n    \"\"\"\n    Calculates the total number of species in an array of habitat patches.\n\n    :param habitat_sizes: list of floats, array of habitat patch sizes\n    :param z: float, coefficient for the power-law relationship\n    :param c: float, proportional constant in the species-area relationship\n    :return: int, total number of species\n    \"\"\"\n    species_counts = [habitat_size_to_species(area, z, c) for area in habitat_sizes]\n    return int(sum(species_counts))\n\n# Example usage\nhabitat_sizes_example = [10, 20, 30, 40, 50]\nz_example = 0.2\nc_example = 10\n\ntotal_species_count = total_species(habitat_sizes_example, z_example, c_example)\nprint(f\"Total number of species in the example habitat patches: {total_species_count}\")\n```\n\nHere is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom habitat_fragmentation import habitat_size_to_species, total_species\n\ndef test_habitat_size_to_species():\n    assert habitat_size_to_species(10, 0.2, 10) == 10 * (10 ** 0.2)\n    assert habitat_size_to_species(20, 0.15, 5) == 5 * (20 ** 0.15)\n\n\ndef test_total_species():\n    habitat_sizes = [10, 20, 30, 40, 50]\n    z = 0.2\n    c = 10\n    assert total_species(habitat_sizes, z, c) == int(10 * (10 ** 0.2) + 10 * (20 ** 0.2) + 10 * (30 ** 0.2) + 10 * (40 ** 0.2) + 10 * (50 ** 0.2))\n\n    other_habitat_sizes = [5, 15, 25, 35, 45]\n    other_z = 0.15\n    other_c = 5\n    assert total_species(other_habitat_sizes, other_z, other_c) == int(5 * (5 ** 0.15) + 5 * (15 ** 0.15) + 5 * (25 ** 0.15) + 5 * (35 ** 0.15) + 5 * (45 ** 0.15))\n\nif __name__ == \"__main__\":\n    pytest.main()\n```"}, {"key": "ConceptualPromptV2_15", "prompt": "Create Python code to implement k-Nearest Neighbors (k-NN) algorithm for classification. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a simple implementation of the k-Nearest Neighbors (k-NN) algorithm for classification using Python:\n\n```python\nimport numpy as np\nfrom collections import Counter\nfrom scipy.spatial.distance import euclidean\n\nclass KNearestNeighbors:\n    def __init__(self, k=3):\n        self.k = k\n\n    def fit(self, X_train, Y_train):\n        self.X_train = X_train\n        self.Y_train = Y_train\n\n    def predict_single(self, x):\n        distances = [euclidean(x, x_train) for x_train in self.X_train]\n        sorted_indices = np.argsort(distances)\n        nearest_neighbors = [self.Y_train[i] for i in sorted_indices[:self.k]]\n        return Counter(nearest_neighbors).most_common(1)[0][0]\n\n    def predict(self, X_predict):\n        return np.array([self.predict_single(x) for x in X_predict])\n\ndef accuracy(y_true, y_pred):\n    return np.sum(y_true == y_pred) / len(y_true)\n```\n\nThen, a set of pytest tests for each function can be written as follows:\n\n```python\nimport numpy as np\nfrom knn import KNearestNeighbors, accuracy\n\ndef test_KNearestNeighbors():\n\n    X_train = np.array([[2, 3], [4, 5], [5, 6], [1, 3]])\n    Y_train = np.array([0, 1, 1, 0])\n    X_test = np.array([[1, 2], [5, 7]])\n    Y_test = np.array([0, 1])\n\n    knn = KNearestNeighbors(k=3)\n    knn.fit(X_train, Y_train)\n    y_pred = knn.predict(X_test)\n\n    assert y_pred[0] == Y_test[0]\n    assert y_pred[1] == Y_test[1]\n\ndef test_accuracy():\n\n    y_true = np.array([0, 1, 1, 0])\n    y_pred1 = np.array([0, 1, 0, 0])\n    y_pred2 = np.array([0, 1, 1, 1])\n\n    accuracy1 = accuracy(y_true, y_pred1)\n    accuracy2 = accuracy(y_true, y_pred2)\n\n    assert accuracy1 == 0.75\n    assert accuracy2 == 0.5\n```"}, {"key": "ConceptualPromptV2_89", "prompt": "Create a Python function to calculate the net present value of an investment, given a series of cash flows, the discount rate, and the initial investment. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python function to calculate the net present value (NPV) of an investment:\n\n```python\ndef npv(cash_flows, discount_rate, initial_investment):\n    \"\"\"\n    Calculate the net present value of an investment given a series of cash flows, a discount rate, and an initial investment.\n    \n    :param cash_flows: List of cash flows where the index represents the period (e.g., cash_flows[0] is for period 1)\n    :param discount_rate: The discount rate to be applied to the cash flows to bring them to present value\n    :param initial_investment: The initial investment made at time zero\n    :return: The net present value of the investment\n    \"\"\"\n    pv_cash_flows = [cf / (1 + discount_rate)**(i + 1) for i, cf in enumerate(cash_flows)]\n    return sum(pv_cash_flows) - initial_investment\n```\n\nNow, here are some pytest tests to exercise the functions:\n\n```python\nimport pytest\nfrom npv_calculation import npv\n\ndef test_npv_basic():\n    cash_flows = [1000, 2000, 3000]\n    discount_rate = 0.10\n    initial_investment = 4000\n    expected_npv = 1892.344498\n  \n    result = npv(cash_flows, discount_rate, initial_investment)\n    assert round(result, 6) == pytest.approx(expected_npv)\n\ndef test_npv_zero_discount_rate():\n    cash_flows = [1000, 2000, 3000]\n    discount_rate = 0\n    initial_investment = 4000\n    expected_npv = 2000\n  \n    result = npv(cash_flows, discount_rate, initial_investment)\n    assert round(result, 6) == pytest.approx(expected_npv)\n\ndef test_negative_cash_flows():\n    cash_flows = [1000, -2000, 3000]\n    discount_rate = 0.05\n    initial_investment = 2000\n    expected_npv = 506.331674\n\n    result = npv(cash_flows, discount_rate, initial_investment)\n    assert round(result, 6) == pytest.approx(expected_npv)\n```"}, {"key": "ConceptualPromptV2_60", "prompt": "Write a Python code to calculate the carrying capacity of an ecosystem, given the population growth rate, initial population size, and maximum sustainable population. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code to calculate the carrying capacity of an ecosystem:\n\n```python\ndef carrying_capacity(rate, initial_population, max_population):\n    \"\"\"\n    Calculate the carrying capacity of an ecosystem.\n\n    Parameters:\n    rate (float): Population growth rate.\n    initial_population (int): Initial population size.\n    max_population (int): Maximum sustainable population.\n\n    Returns:\n    float: Carrying capacity of the ecosystem.\n    \"\"\"\n\n    return (rate * initial_population * (max_population - initial_population)) / max_population\n\n# Example values\ngrowth_rate = 0.1\ninitial_pop = 100\nmax_sustainable_population = 1000\n\n# Calculate the carrying capacity\ncapacity = carrying_capacity(growth_rate, initial_pop, max_sustainable_population)\nprint(\"Carrying capacity:\", capacity)\n```\n\nHere are some pytest tests for the `carrying_capacity` function:\n\n```python\nimport pytest\nfrom ecosystem import carrying_capacity\n\ndef test_carrying_capacity():\n    # Test with sample values\n    assert carrying_capacity(0.1, 100, 1000) == 90.0\n\n    # Test with zero rate\n    assert carrying_capacity(0, 100, 1000) == 0\n\n    # Test with zero initial population\n    assert carrying_capacity(0.1, 0, 1000) == 0\n\n    # Test with equal initial and maximum population\n    assert carrying_capacity(0.1, 1000, 1000) == 0\n\n    # Test with irrational numbers\n    assert carrying_capacity(0.333, 500, 1234) == pytest.approx(138.327, rel=1e-3)\n```\n\nMake sure to save the first code snippet in a file named `ecosystem.py` and the second code snippet in a separate file named `test_ecosystem.py`. Then, run `pytest test_ecosystem.py` to test the function."}, {"key": "ConceptualPromptV2_51", "prompt": "Develop a Python function to implement the Huffman coding algorithm for data compression. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of the Huffman Coding algorithm, comprised of several modular functions:\n\n```python\nimport heapq\nfrom collections import defaultdict\n\ndef calc_frequencies(data):\n    freq = defaultdict(int)\n    for char in data:\n        freq[char] += 1\n    return freq\n\ndef create_huffman_tree(freq):\n    heap = [[weight, [char, \"\"]] for char, weight in freq.items()]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        lo = heapq.heappop(heap)\n        hi = heapq.heappop(heap)\n        \n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n            \n        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return heap[0]\n\ndef generate_huffman_dict(huff_tree):\n    huff_dict = {}\n    for pair in huff_tree[1:]:\n        char, code = pair\n        huff_dict[char] = code\n    return huff_dict\n\ndef compress_data(data, huff_dict):\n    compressed_data = \"\"\n    for char in data:\n        compressed_data += huff_dict[char]\n    return compressed_data\n\ndef huffman_encoding(data):\n    freq = calc_frequencies(data)\n    huff_tree = create_huffman_tree(freq)\n    huff_dict = generate_huffman_dict(huff_tree)\n\n    compressed_data = compress_data(data, huff_dict)\n    \n    return huff_dict, compressed_data\n```\n\nHere's a set of pytest tests that can be used to test each part of the Huffman Coding algorithm:\n\n```python\nimport pytest\nfrom huffman import calc_frequencies, create_huffman_tree, generate_huffman_dict, compress_data, huffman_encoding\n\ndef test_calc_frequencies():\n    data = \"aabcc\"\n    freq = calc_frequencies(data)\n    assert freq == {'a': 2, 'b': 1, 'c': 2}\n\ndef test_create_huffman_tree():\n    freq = {'a': 2, 'b': 1, 'c': 2}\n    huff_tree = create_huffman_tree(freq)\n    assert huff_tree == [5, ['a', '0'], ['c', '10'], ['b', '11']]\n\ndef test_generate_huffman_dict():\n    huff_tree = [5, ['a', '0'], ['c', '10'], ['b', '11']]\n    huff_dict = generate_huffman_dict(huff_tree)\n    assert huff_dict == {'a': '0', 'c': '10', 'b': '11'}\n\ndef test_compress_data():\n    data = \"aabcc\"\n    huff_dict = {'a': '0', 'c': '10', 'b': '11'}\n    compressed_data = compress_data(data, huff_dict)\n    assert compressed_data == \"0010110\"\n\ndef test_huffman_encoding():\n    data = \"aabcc\"\n    huff_dict, compressed_data = huffman_encoding(data)\n    assert huff_dict == {'a': '0', 'c': '10', 'b': '11'}\n    assert compressed_data == \"0010110\"\n```\n\nThese tests cover most of the basic functionality for data compression using this Huffman Coding implementation."}, {"key": "ConceptualPromptV2_61", "prompt": "Create a Python function to model the population growth of a species using the logistic growth equation, given the initial population size, carrying capacity, and growth rate. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python function that models the population growth using the logistic growth equation:\n\n```python\ndef logistic_growth(initial_population, carrying_capacity, growth_rate, time):\n    \"\"\"\n    Calculate the population size at a given time using the logistic growth equation.\n    \n    :param initial_population: The initial population size (float or int)\n    :param carrying_capacity: The maximum population size the environment can support (float or int)\n    :param growth_rate: The intrinsic growth rate (float)\n    :param time: The time at which to evaluate the population growth (float or int)\n    :return: The population size at the given time (float)\n    \"\"\"\n    population = carrying_capacity / (1 + ((carrying_capacity - initial_population) / initial_population) * (2 ** (-growth_rate * time)))\n    return population\n```\n\nHere's a set of pytest tests to exercise the function:\n```python\nimport pytest\nfrom population_growth import logistic_growth\n\n\n@pytest.mark.parametrize(\"initial_population, carrying_capacity, growth_rate, time, expected_population\", [\n    (1000, 2000, 0.5, 1, 1333.3333333333333),\n    (500, 3000, 0.25, 2, 836.7956749718554),\n    (1500, 5000, 0.75, 3, 2586.032629558541),\n])\ndef test_logistic_growth(initial_population, carrying_capacity, growth_rate, time, expected_population):\n    result = logistic_growth(initial_population, carrying_capacity, growth_rate, time)\n    assert round(result, 2) == round(expected_population, 2)\n```"}, {"key": "ConceptualPromptV2_1", "prompt": "Generate Python code to implement a linear regression model using the least squares method. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to implement a linear regression model using the least squares method:\n\n```python\nimport numpy as np\n\ndef get_data():\n    # Example data (x, y)\n    x = np.array([1, 2, 3, 4, 5])    \n    y = np.array([2, 4, 5, 4, 5])\n\n    return x, y\n\ndef calculate_means(x, y):\n    # Calculate mean values\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n\n    return x_mean, y_mean\n\ndef calculate_coefficients(x, y, x_mean, y_mean):\n    # Calculate slope (m) and intercept (b) of the linear regression\n    m = np.sum((x - x_mean) * (y - y_mean)) / np.sum((x - x_mean)**2)\n    b = y_mean - m * x_mean\n\n    return m, b\n\ndef linear_regression(x, y):\n    x_mean, y_mean = calculate_means(x, y)\n    m, b = calculate_coefficients(x, y, x_mean, y_mean)\n\n    return m, b\n\ndef test_data():\n    x_data, y_data = get_data()\n\n    assert len(x_data) == len(y_data), \"Data lengths should be equal\"\n\ndef test_calculate_means():\n    x_data, y_data = get_data()\n\n    x_mean, y_mean = calculate_means(x_data, y_data)\n\n    assert x_mean == np.mean(x_data), \"X mean should be equal to numpy mean\"\n    assert y_mean == np.mean(y_data), \"Y mean should be equal to numpy mean\"\n\ndef test_calculate_coefficients():\n    x_data, y_data = get_data()\n\n    x_mean, y_mean = calculate_means(x_data, y_data)\n    m, b = calculate_coefficients(x_data, y_data, x_mean, y_mean)\n\n    assert isinstance(m, float), \"Slope should be a float value\"\n    assert isinstance(b, float), \"Intercept should be a float value\"\n\ndef test_linear_regression():\n    x_data, y_data = get_data()\n\n    m, b = linear_regression(x_data, y_data)\n\n    assert isinstance(m, float), \"Slope should be a float value\"\n    assert isinstance(b, float), \"Intercept should be a float value\"\n\nif __name__ == \"__main__\":\n    x, y = get_data()\n    m, b = linear_regression(x, y)\n\n    print(\"Slope (m):\", m)\n    print(\"Intercept (b):\", b)\n```\n\nHere are the pytest tests to exercise each of the functions:\n\n```python\nimport pytest\nfrom your_module import get_data, test_data, calculate_means, test_calculate_means, calculate_coefficients, test_calculate_coefficients, linear_regression, test_linear_regression\n\ndef test_get_data():\n    x_data, y_data = get_data()\n\n    assert len(x_data) == len(y_data), \"Data lengths should be equal\"\n\ndef test_calculate_means():\n    x_data, y_data = get_data()\n\n    x_mean, y_mean = calculate_means(x_data, y_data)\n\n    assert x_mean == np.mean(x_data), \"X mean should be equal to numpy mean\"\n    assert y_mean == np.mean(y_data), \"Y mean should be equal to numpy mean\"\n\ndef test_calculate_coefficients():\n    x_data, y_data = get_data()\n\n    x_mean, y_mean = calculate_means(x_data, y_data)\n    m, b = calculate_coefficients(x_data, y_data, x_mean, y_mean)\n\n    assert isinstance(m, float), \"Slope should be a float value\"\n    assert isinstance(b, float), \"Intercept should be a float value\"\n\ndef test_linear_regression():\n    x_data, y_data = get_data()\n\n    m, b = linear_regression(x_data, y_data)\n\n    assert isinstance(m, float), \"Slope should be a float value\"\n    assert isinstance(b, float), \"Intercept should be a float value\"\n\n```\nMake sure to replace `your_module` with the appropriate module name in the import statement. These tests can be run with `pytest`."}, {"key": "ConceptualPromptV2_80", "prompt": "Write a Python code to calculate the compound interest earned on an investment, given the principal amount, interest rate, and the number of years. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to calculate the compound interest earned on an investment:\n\n```python\ndef compound_interest(principal, rate, time, frequency):\n    \"\"\"\n    Calculate compound interest given principal, rate, time, and frequency of compounding.\n\n    :param principal: Initial investment amount\n    :param rate: Interest rate (in decimals, e.g., 0.05 for 5%)\n    :param time: Number of years for the investment\n    :param frequency: Number of times interest is compounded per year\n    :return: Total amount after interest\n    \"\"\"\n    total_amount = principal * (1 + rate / frequency)**(frequency * time)\n    return total_amount\n\ndef interest_earned(total_amount, principal):\n    \"\"\"\n    Calculate interest earned given total amount and principal.\n\n    :param total_amount: Total amount after interest\n    :param principal: Initial investment amount\n    :return: Interest earned\n    \"\"\"\n    interest = total_amount - principal\n    return interest\n\n# Example usage\nprincipal = 5000\nrate = 0.05\ntime = 10\nfrequency = 12\n\ntotal_amount = compound_interest(principal, rate, time, frequency)\ninterest = interest_earned(total_amount, principal)\n\nprint(\"Total amount:\", round(total_amount, 2))\nprint(\"Interest earned:\", round(interest, 2))\n```\n\nHere's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\n\nfrom compound_interest import compound_interest, interest_earned\n\ndef test_compound_interest():\n    principal = 5000\n    rate = 0.05\n    time = 10\n    frequency = 12\n    total_amount = compound_interest(principal, rate, time, frequency)\n    assert round(total_amount, 2) == 8235.05\n\ndef test_interest_earned():\n    total_amount = 8235.05\n    principal = 5000\n    interest = interest_earned(total_amount, principal)\n    assert round(interest, 2) == 3235.05\n\nif __name__ == \"__main__\":\n    pytest.main([\"-v\"])\n```"}, {"key": "ConceptualPromptV2_59", "prompt": "Develop a Python function to implement the Kruskal's algorithm for finding the minimum spanning tree of an undirected graph. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python implementation of Kruskal's algorithm for finding the minimum spanning tree of an undirected graph.\n\n```python\ndef kruskal(graph):\n    \"\"\"\n    Find the minimum spanning tree of an undirected graph using Kruskal's algorithm.\n    \n    :param graph: A dictionary representing the adjacency list of the graph,\n                  where the keys are the nodes, and the values are lists of tuples\n                  with a neighboring node and the edge weight.\n    :return: A list of tuples representing the minimum spanning tree edges.\n    \"\"\"\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        x_root = find(parent, x)\n        y_root = find(parent, y)\n\n        if rank[x_root] < rank[y_root]:\n            parent[x_root] = y_root\n        elif rank[x_root] > rank[y_root]:\n            parent[y_root] = x_root\n        else:\n            parent[y_root] = x_root\n            rank[x_root] += 1\n\n    nodes = list(graph.keys())\n    edges = []\n    for node in graph:\n        for neighbor, weight in graph[node]:\n            edges.append((node, neighbor, weight))\n\n    edges.sort(key=lambda x: x[2])\n\n    parent = {}\n    rank = {}\n\n    for node in nodes:\n        parent[node] = node\n        rank[node] = 0\n\n    mst = []\n\n    while len(mst) < len(nodes) - 1:\n        u, v, w = edges.pop(0)\n        u_root = find(parent, u)\n        v_root = find(parent, v)\n\n        if u_root != v_root:\n            mst.append((u, v, w))\n            union(parent, rank, u_root, v_root)\n\n    return mst\n```\n\nHere is a set of `pytest` tests to exercise the `kruskal` function:\n\n```python\nimport pytest\nfrom kruskal import kruskal\n\ndef test_kruskal_simple():\n    graph = {\n        0: [(1, 10), (2, 6), (3, 5)],\n        1: [(0, 10), (3, 15)],\n        2: [(0, 6), (3, 4)],\n        3: [(0, 5), (1, 15), (2, 4)]\n    }\n    mst = kruskal(graph)\n    assert sorted(mst) == [(0, 1, 10), (0, 3, 5), (2, 3, 4)]\n\ndef test_kruskal_complex():\n    graph = {\n        'A': [('B', 7), ('D', 5)],\n        'B': [('A', 7), ('C', 8), ('D', 9), ('E', 7)],\n        'C': [('B', 8), ('E', 5)],\n        'D': [('A', 5), ('B', 9), ('E', 15), ('F', 6)],\n        'E': [('B', 7), ('C', 5), ('D', 15), ('F', 8), ('G', 9)],\n        'F': [('D', 6), ('E', 8), ('G', 11)],\n        'G': [('E', 9), ('F', 11)]\n    }\n    mst = kruskal(graph)\n    assert sorted(mst) == [('A', 'B', 7), ('A', 'D', 5), ('B', 'E', 7), ('C', 'E', 5), ('D', 'F', 6), ('E', 'G', 9)]\n\ndef test_kruskal_single_edge():\n    graph = {0: [(1, 15)], 1: [(0, 15)]}\n    mst = kruskal(graph)\n    assert sorted(mst) == [(0, 1, 15)]\n\ndef test_kruskal_no_edges():\n    graph = {0: [], 1: []}\n    mst = kruskal(graph)\n    assert sorted(mst) == []\n```"}, {"key": "ConceptualPromptV2_70", "prompt": "Write a Python program to estimate the extinction risk of a species based on the species-area relationship and habitat loss. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python program that estimates the extinction risk of a species based on the species-area relationship and habitat loss:\n\n```python\nimport numpy as np\n\ndef species_area_relationship(z, initial_area, final_area):\n    \"\"\"\n    Calculates the number of species after habitat loss using species-area relationship.\n\n    Args:\n    - z (float): The species-area exponent (usually between 0.1 and 0.2).\n    - initial_area (float): The initial area of the habitat in square kilometers.\n    - final_area (float): The final area of the habitat after habitat loss in square kilometers.\n\n    Returns:\n    - float: The proportion of species remaining after habitat loss.\n    \"\"\"\n\n    proportion_remaining = (final_area / initial_area)**z\n    return proportion_remaining\n\ndef estimate_extinction_risk(species_remaining, extinction_threshold=0.5):\n    \"\"\"\n    Estimates the extinction risk of a species based on the proportion of species remaining.\n\n    Args:\n    - species_remaining (float): The proportion of species remaining after habitat loss.\n    - extinction_threshold (float, optional): The threshold below which a species is at risk of extinction.\n\n    Returns:\n    - bool: True if the species is at risk of extinction, False otherwise.\n    \"\"\"\n\n    if species_remaining < extinction_threshold:\n        return True\n    return False\n\ndef main():\n    # Example: Habitat loss from 1000 sq.km to 500 sq.km, species-area exponent (z) = 0.15\n    z = 0.15\n    initial_area = 1000\n    final_area = 500\n\n    species_remaining = species_area_relationship(z, initial_area, final_area)\n    extinction_risk = estimate_extinction_risk(species_remaining)\n\n    print(f\"The proportion of species remaining is {species_remaining:.2f}\")\n    print(f\"Extinction risk: {extinction_risk}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nHere is a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom extinction_risk import species_area_relationship, estimate_extinction_risk\n\ndef test_species_area_relationship():\n    assert species_area_relationship(0.15, 1000, 500) == pytest.approx(0.693)\n    assert species_area_relationship(0.2, 500, 250) == pytest.approx(0.574)\n\ndef test_estimate_extinction_risk():\n    assert estimate_extinction_risk(0.6) == False\n    assert estimate_extinction_risk(0.4) == True\n    assert estimate_extinction_risk(0.6, extinction_threshold=0.7) == True\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n```\n\nRemember to save the main code in a file called `extinction_risk.py` and the tests in a file called `test_extinction_risk.py`. To run the tests, execute the command `pytest test_extinction_risk.py` in the terminal."}, {"key": "ConceptualPromptV2_99", "prompt": "Develop a Python code to model the Keynesian aggregate expenditure model, given the consumption function, investment, government spending, and net exports. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code for the Keynesian aggregate expenditure model:\n\n```python\ndef consumption_function(consumption, marginal_propensity_to_consume, disposable_income):\n    return consumption + marginal_propensity_to_consume * disposable_income\n\ndef aggregate_expenditure(consumption, investment, government_spending, net_exports):\n    return consumption + investment + government_spending + net_exports\n\ndef keynesian_model(income, consumption, marginal_propensity_to_consume, investment, government_spending, net_exports):\n    disposable_income = income\n    total_consumption = consumption_function(consumption, marginal_propensity_to_consume, disposable_income)\n    total_expenditure = aggregate_expenditure(total_consumption, investment, government_spending, net_exports)\n    return total_expenditure\n\n# Example values\nincome = 1000\nconsumption = 200\nmarginal_propensity_to_consume = 0.6\ninvestment = 150\ngovernment_spending = 300\nnet_exports = 50\n\ntotal_expenditure = keynesian_model(income, consumption, marginal_propensity_to_consume, investment, government_spending, net_exports)\nprint(\"Total Expenditure:\", total_expenditure)\n```\n\nAnd here's a set of pytest tests to test the functions:\n\n```python\nimport pytest\nfrom keynesian_model import consumption_function, aggregate_expenditure, keynesian_model\n\ndef test_consumption_function():\n    assert consumption_function(200, 0.6, 1000) == 800\n    assert consumption_function(100, 0.8, 500) == 500\n    assert consumption_function(300, 0.5, 1500) == 1050\n\ndef test_aggregate_expenditure():\n    assert aggregate_expenditure(800, 150, 300, 50) == 1300\n    assert aggregate_expenditure(500, 100, 400, 30) == 1030\n    assert aggregate_expenditure(1050, 200, 500, 20) == 1770\n\ndef test_keynesian_model():\n    assert keynesian_model(1000, 200, 0.6, 150, 300, 50) == 1300\n    assert keynesian_model(500, 100, 0.8, 100, 400, 30) == 1030\n    assert keynesian_model(1500, 300, 0.5, 200, 500, 20) == 1770\n```\n\nSave the tests in a separate file and run them with pytest. Make sure to import the necessary functions from the main code file to the test file."}, {"key": "ConceptualPromptV2_23", "prompt": "Create Python code to calculate the final velocity of an object in free fall, given its initial velocity and the time elapsed. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code for calculating the final velocity of an object in free fall, given its initial velocity and the time elapsed:\n\n```python\ndef final_velocity(initial_velocity, time_elapsed, gravity=-9.81):\n    \"\"\"\n    Calculate the final velocity of an object in free fall given\n    the initial velocity, time elapsed, and acceleration due to gravity.\n    \n    Args:\n    initial_velocity (float): Initial velocity of the object (m/s)\n    time_elapsed (float): Time elapsed during free fall (s)\n    gravity (float, optional): Acceleration due to gravity (m/s^2). Default is -9.81.\n\n    Returns:\n    float: Final velocity of the object after the specified time (m/s)\n    \"\"\"\n    return initial_velocity + (gravity * time_elapsed)\n\nif __name__ == \"__main__\":\n    iv = 0  # Initial velocity (m/s)\n    te = 3  # Time elapsed (s)\n    final_v = final_velocity(iv, te)\n    print(f\"Final velocity: {final_v} m/s\")\n```\n\nNow, let's create a set of pytest tests that exercise each function:\n\n```python\nimport pytest\nfrom free_fall_calculator import final_velocity\n\ndef test_final_velocity():\n    assert final_velocity(0, 3) == pytest.approx(-29.43)\n    assert final_velocity(10, 5) == pytest.approx(-39.05)\n    assert final_velocity(-5, 2) == pytest.approx(-24.62)\n    assert final_velocity(20, 0) == pytest.approx(20)\n```\n\nNote: In the second code block, it's assumed that the first code block is saved in a file named `free_fall_calculator.py`. Simply run `pytest` from the command line after saving these two files to test the function."}, {"key": "ConceptualPromptV2_25", "prompt": "Create Python code to determine the electric field at a point in space due to a point charge, given the charge and the distance from the point to the charge. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code to determine the electric field at a point in space due to a point charge:\n\n```python\nimport math\n\ndef electric_field(charge, distance):\n    \"\"\"\n    Calculate the electric field at a point in space due to a point charge.\n\n    :param charge: float\n        Charge of the point charge in coulombs.\n    :param distance: float\n        Distance from the point to the charge in meters.\n    :return: electric field in N/C (newtons per coulomb)\n    \"\"\"\n    k = 8.9875517923e9  # Coulomb's constant, N\u00b7m\u00b2/C\u00b2\n    electric_field = k * charge / (distance ** 2)\n    return electric_field\n\n# example usage\nq = 1e-6  # 1 microcoulomb\nd = 0.01  # 1 centimeter\nE = electric_field(q, d)\nprint(f\"Electric field due to a {q:.1e} C charge at a distance of {d} m: {E:.3e} N/C\")\n```\n\nHere are the pytest tests:\n\n```python\nimport pytest\n\ndef test_electric_field():\n    q = 1e-6  # 1 microcoulomb\n    d = 0.01  # 1 centimeter\n    expected = 8.9875517923e9 * q / (d ** 2)\n    result = electric_field(q, d)\n    assert math.isclose(result, expected, rel_tol=1e-9)\n\ndef test_zero_input():\n    q = 0\n    d = 1\n    expected = 0\n    result = electric_field(q, d)\n    assert result == expected\n\ndef test_negative_charge():\n    q = -1e-6\n    d = 0.01\n    expected = 8.9875517923e9 * q / (d ** 2)\n    result = electric_field(q, d)\n    assert math.isclose(result, expected, rel_tol=1e-9)\n\n@pytest.mark.parametrize(\"q, d\", [\n    (1e-6, -0.01),\n    (-1e-6, -0.01),\n])\ndef test_negative_distance(q, d):\n    with pytest.raises(ValueError):\n        electric_field(q, d)\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n```"}, {"key": "ConceptualPromptV2_35", "prompt": "Create a Python function to compute the diffraction angle of light through a single slit, given the wavelength of the light, the width of the slit, and the distance to the screen. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a simple and modular code to calculate the diffraction angle for light through a single slit:\n\n```python\nimport math\n\n# Default values for wavelength, slit_width, and screen_distance in meters.\nDEFAULT_WAVELENGTH = 6.3e-7\nDEFAULT_SLIT_WIDTH = 0.001\nDEFAULT_SCREEN_DISTANCE = 1.0\n\ndef diffraction_angle(wavelength, slit_width, screen_distance):\n    \"\"\"\n    Compute the diffraction angle of light through a single slit.\n\n    Args:\n        wavelength (float): Wavelength of light in meters.\n        slit_width (float): Width of the slit in meters.\n        screen_distance (float): Distance from the slit to the screen in meters.\n    \n    Returns:\n        float: The diffraction angle in radians.\n    \"\"\"\n    angle = math.asin(wavelength / slit_width)\n\n    if screen_distance > 0:\n        return angle\n    else:\n        raise ValueError(\"The distance to the screen must be greater than 0.\")\n\n# Example usage\nangle = diffraction_angle(DEFAULT_WAVELENGTH, DEFAULT_SLIT_WIDTH, DEFAULT_SCREEN_DISTANCE)\nprint(f\"Diffraction angle: {angle:.10f} radians\")\n```\n\nHere's a set of pytest tests for this code:\n\n```python\nimport pytest\nfrom diffraction_angle_calculator import diffraction_angle\n\ndef test_diffraction_angle():\n    wavelength = 6.3e-7\n    slit_width = 0.001\n    screen_distance = 1.0\n\n    angle = diffraction_angle(wavelength, slit_width, screen_distance)\n    assert round(angle, 10) == 0.0006300000\n\ndef test_invalid_screen_distance():\n    wavelength = 6.3e-7\n    slit_width = 0.001\n    screen_distance = 0\n\n    with pytest.raises(ValueError, match=\"The distance to the screen must be greater than 0\"):\n        diffraction_angle(wavelength, slit_width, screen_distance)\n\ndef test_large_screen_distance():\n    wavelength = 6.3e-7\n    slit_width = 0.001\n    screen_distance = 100.0\n\n    angle = diffraction_angle(wavelength, slit_width, screen_distance)\n    assert round(angle, 10) == 0.0006300000\n```\n\nMake sure to save the function in a file named `diffraction_angle_calculator.py` for the tests to work since the tests import the function from that file."}, {"key": "ConceptualPromptV2_78", "prompt": "Write a Python program to analyze the impact of habitat connectivity on species dispersal, given the distances between habitat patches and the species' dispersal abilities. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python program to analyze the impact of habitat connectivity on species dispersal. I've provided sample data for distances between habitats and species' dispersal abilities, but you can change them as needed.\n\n```python\nimport numpy as np\n\n# Distances between habitat patches (in meters)\ndistances = np.array([[0, 1000, 5000],\n                      [1000, 0, 3000],\n                      [5000, 3000, 0]])\n\n# Species' dispersal abilities (in meters)\nspecies_dispersal_abilities = np.array([800, 2000, 4000])\n\ndef calculate_connectivity_matrix(distances, dispersal_abilities):\n    \"\"\"\n    Calculate the connectivity matrix between habitat patches.\n    \"\"\"\n    connectivity_matrix = np.zeros_like(distances)\n\n    for i in range(len(distances)):\n        for j in range(len(distances)):\n            if distances[i, j] <= dispersal_abilities[min(i, j)]:\n                connectivity_matrix[i, j] = 1\n\n    return connectivity_matrix\n\ndef get_connected_habitat_pairs(connectivity_matrix):\n    \"\"\"\n    Get a list of connected habitat pairs.\n    \"\"\"\n    connected_pairs = []\n\n    for i in range(len(connectivity_matrix)):\n        for j in range(i + 1, len(connectivity_matrix)):\n            if connectivity_matrix[i, j] == 1:\n                connected_pairs.append((i, j))\n\n    return connected_pairs\n\ndef analyze_species_dispersal(distances, dispersal_abilities):\n    \"\"\"\n    Analyze the impact of habitat connectivity on species dispersal.\n    \"\"\"\n    connectivity_matrix = calculate_connectivity_matrix(distances, dispersal_abilities)\n    connected_pairs = get_connected_habitat_pairs(connectivity_matrix)\n\n    return connected_pairs\n\n# Analyze the species dispersal in the given habitats and dispersal abilities\nconnected_pairs = analyze_species_dispersal(distances, species_dispersal_abilities)\nprint(\"Connected habitat pairs:\", connected_pairs)\n```\n\nAnd here is a set of pytest tests for each of the functions:\n\n```python\nimport pytest\n\ndef test_calculate_connectivity_matrix():\n    distances = np.array([[0, 1000, 5000],\n                          [1000, 0, 3000],\n                          [5000, 3000, 0]])\n    dispersal_abilities = np.array([800, 2000, 4000])\n\n    expected_connectivity_matrix = np.array([[0, 1, 0],\n                                             [1, 0, 1],\n                                             [0, 1, 0]])\n\n    result = calculate_connectivity_matrix(distances, dispersal_abilities)\n    assert np.array_equal(result, expected_connectivity_matrix)\n\ndef test_get_connected_habitat_pairs():\n    connectivity_matrix = np.array([[0, 1, 0],\n                                     [1, 0, 1],\n                                     [0, 1, 0]])\n\n    expected_connected_pairs = [(0, 1), (1, 2)]\n\n    result = get_connected_habitat_pairs(connectivity_matrix)\n    assert result == expected_connected_pairs\n\ndef test_analyze_species_dispersal():\n    distances = np.array([[0, 1000, 5000],\n                          [1000, 0, 3000],\n                          [5000, 3000, 0]])\n    dispersal_abilities = np.array([800, 2000, 4000])\n\n    expected_connected_pairs = [(0, 1), (1, 2)]\n\n    result = analyze_species_dispersal(distances, dispersal_abilities)\n    assert result == expected_connected_pairs\n\n```"}, {"key": "ConceptualPromptV2_79", "prompt": "Develop a Python code to model the population dynamics of a species in response to environmental stochasticity, given the vital rates, carrying capacity, and environmental variability. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python code to model the population dynamics of a species.\n\n```python\nimport numpy as np\n\ndef next_population(population, birth_rate, death_rate, carrying_capacity):\n    # Calculate the net growth rate, considering intrinsic birth and death rates\n    growth_rate = birth_rate - death_rate\n    \n    # Implement the logistic growth model\n    population_change = growth_rate * population * (1 - population / carrying_capacity)\n    next_population = population + population_change\n    return next_population\n\ndef apply_environmental_stochasticity(population, var):\n    # Apply environmental stochasticity\n    random_factor = np.random.normal(1, var)\n    population = population * random_factor\n    return max(0, population)\n\ndef simulate_population_dynamics(initial_population, birth_rate, death_rate, carrying_capacity, env_stochasticity, n_years):\n    populations = [initial_population]\n    \n    for _ in range(n_years):\n        next_pop = next_population(populations[-1], birth_rate, death_rate, carrying_capacity)\n        next_pop = apply_environmental_stochasticity(next_pop, env_stochasticity)\n        populations.append(next_pop)\n    \n    return populations\n\n# Example values\ninitial_population = 100\nbirth_rate = 0.3\ndeath_rate = 0.1\ncarrying_capacity = 500\nenv_stochasticity = 0.05\nn_years = 25\n\nsimulated_populations = simulate_population_dynamics(initial_population, birth_rate, death_rate, carrying_capacity, env_stochasticity, n_years)\nprint(simulated_populations)\n```\n\nHere's a set of pytest tests to exercise each of the functions.\n\n```python\nimport pytest\nfrom your_module import next_population, apply_environmental_stochasticity, simulate_population_dynamics\n\ndef test_next_population():\n    assert next_population(100, 0.3, 0.1, 500) == 110\n    assert next_population(200, 0.4, 0.2, 300) == 190\n\ndef test_apply_environmental_stochasticity():\n    np.random.seed(42)\n    assert np.isclose(apply_environmental_stochasticity(100, 0.05), 99.40441493)\n    assert np.isclose(apply_environmental_stochasticity(200, 0.1), 186.22433877)\n\ndef test_simulate_population_dynamics():\n    np.random.seed(42)\n    sim_pop = simulate_population_dynamics(10, 0.3, 0.1, 50, 0.05, 5)\n    expected_pop = [10, 21.89875327, 40.58503309, 50.8704097, 50.98687313, 49.92140979]\n    \n    for i in range(5):\n        assert np.isclose(sim_pop[i], expected_pop[i])\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\n\nYou will need to replace `from your_module` with the appropriate import statement for your project. The tests assume you have these functions defined in a module you've created."}, {"key": "ConceptualPromptV2_8", "prompt": "Create a Python function to compute the cumulative distribution function (CDF) of a given probability distribution. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python function to compute the cumulative distribution function (CDF) of a given probability distribution:\n\n```python\nimport numpy as np\n\ndef cumulative_distribution_function(prob_distribution):\n    \"\"\"\n    Computes the cumulative distribution function (CDF) for a given probability distribution.\n\n    Args:\n        prob_distribution (list or array): A list or array of probabilities (non-negative values) representing a probability distribution.\n\n    Returns:\n        cdf (list): The computed CDF as a list.\n    \"\"\"\n    if not np.all(np.array(prob_distribution) >= 0):\n        raise ValueError(\"Probability distribution contains negative values.\")\n\n    prob_array = np.array(prob_distribution)\n    if not np.isclose(prob_array.sum(), 1):\n        raise ValueError(\"Probability distribution doesn't sum to 1.\")\n\n    cdf = np.cumsum(prob_array)\n    return cdf.tolist()\n```\n\nNow, here are a set of pytest tests to exercise the above function:\n\n```python\nimport pytest\nfrom cdf import cumulative_distribution_function\n\ndef test_valid_cumulative_distribution_function():\n    prob_dist = [0.1, 0.2, 0.3, 0.4]\n    expected_cdf = [0.1, 0.3, 0.6, 1.0]\n    assert cumulative_distribution_function(prob_dist) == expected_cdf\n\ndef test_invalid_input_negative_values():\n    with pytest.raises(ValueError):\n        cumulative_distribution_function([0.1, -0.2, 0.3, 0.4])\n\ndef test_invalid_input_prob_dist_sum_not_one():\n    with pytest.raises(ValueError):\n        cumulative_distribution_function([0.1, 0.2, 0.3, 0.2])\n\ndef test_empty_input():\n    with pytest.raises(ValueError):\n        cumulative_distribution_function([])\n```"}, {"key": "ConceptualPromptV2_42", "prompt": "Write a Python program to implement the traveling salesman problem using a dynamic programming approach. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python program to implement the traveling salesman problem using a dynamic programming approach:\n\n```python\nimport numpy as np\n\ndef tsp_dp(cities, distance_matrix):\n    n = len(cities)\n    all_visited = (1 << n) - 1 \n\n    memo = np.full((1 << n, n), -1, dtype=int)\n\n    def tsp_dp_helper(visited, current_city):\n        if visited == all_visited:  \n            return distance_matrix[current_city][0]\n\n        if memo[visited][current_city] != -1:\n            return memo[visited][current_city]\n\n        min_distance = float('inf')\n        for next_city in range(n):\n            mask = 1 << next_city\n            if (visited & mask) == 0:\n                next_distance = distance_matrix[current_city][next_city] + tsp_dp_helper(visited | mask, next_city)\n                min_distance = min(min_distance, next_distance)\n\n        memo[visited][current_city] = min_distance\n        return min_distance\n\n    return tsp_dp_helper(1, 0)\n\ndef generate_distance_matrix(cities):\n    n = len(cities)\n    distance_matrix = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = int(np.sqrt((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2))\n            distance_matrix[i][j] = distance\n            distance_matrix[j][i] = distance\n            \n    return distance_matrix\n\nif __name__ == \"__main__\":\n    cities = [(0, 0), (1, 5), (6, 7), (4, 20), (12, 6)]\n    distance_matrix = generate_distance_matrix(cities)\n    shortest_path_length = tsp_dp(cities, distance_matrix)\n    print(\"Shortest path length:\", shortest_path_length)\n```\n\nAnd here's a set of pytest tests to exercise each of the functions:\n\n```python\nimport pytest\nimport numpy as np\nfrom tsp_dp import tsp_dp, generate_distance_matrix\n\ndef test_generate_distance_matrix():\n    cities = [(0, 0), (3, 4)]\n    expected_distance_matrix = np.array([[0, 5],[5, 0]], dtype=int)\n    computed_distance_matrix = generate_distance_matrix(cities)\n    assert np.array_equal(computed_distance_matrix, expected_distance_matrix)\n    \n    cities = [(0, 0), (3, 4), (18, 10)]\n    expected_distance_matrix = np.array([[0, 5, 20], [5, 0, 15], [20, 15, 0]], dtype=int)\n    computed_distance_matrix = generate_distance_matrix(cities)\n    assert np.array_equal(computed_distance_matrix, expected_distance_matrix)\n\ndef test_tsp_dp():\n    cities = [(0, 0), (1, 5), (6, 7), (4, 20), (12, 6)]\n    distance_matrix = generate_distance_matrix(cities)\n    assert tsp_dp(cities, distance_matrix) == 40\n    \n    cities = [(0, 0), (3, 4), (18, 10)]\n    distance_matrix = generate_distance_matrix(cities)\n    assert tsp_dp(cities, distance_matrix) == 30\n```"}, {"key": "ConceptualPromptV2_26", "prompt": "Write a Python program to calculate the potential energy stored in a spring, given the spring constant and the displacement from its equilibrium position. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "I have prepared a Python program for you to calculate the potential energy stored in a spring. Here it is:\n\n```python\ndef potential_energy(spring_constant, displacement):\n    \"\"\"\n    This function calculates the potential energy stored in a spring.\n    :param spring_constant: spring's spring constant (k) in N/m\n    :param displacement: displacement from equilibrium position (x) in meters\n    :return: potential energy (PE) in joules\n    \"\"\"\n    return 0.5 * spring_constant * (displacement ** 2)\n\n\ndef main():\n    spring_constant = 100  # Spring constant (k) in N/m\n    displacement = 0.1  # Displacement from equilibrium position (x) in meters\n\n    # Calculate and display the potential energy\n    pe = potential_energy(spring_constant, displacement)\n    print(f\"The potential energy stored in the spring is {pe} joules.\")\n\n\nif __name__ == '__main__':\n    main()\n```\n\nThe first function, `potential_energy`, calculates the potential energy stored in a spring based on the given spring constant and displacement. The `main` function sets values for the spring constant and displacement, and then calls the `potential_energy` function to find the potential energy. Finally, the potential energy is printed to the console.\n\nHere is a set of pytest tests to exercise the `potential_energy` function:\n\n```python\nimport pytest\nfrom spring_potential_energy import potential_energy\n\ndef test_potential_energy():\n    assert potential_energy(100, 0.1) == 0.5\n    assert potential_energy(200, 0.2) == 4.0\n    assert potential_energy(50, 0.5) == 6.25\n    assert potential_energy(0, 0.3) == 0.0\n    assert potential_energy(100, 0) == 0.0\n```\n\nTo use these tests, you should save the main program in a file called `spring_potential_energy.py`, install pytest, and then run the tests using the `pytest` command."}, {"key": "ConceptualPromptV2_34", "prompt": "Write a Python program to determine the total mechanical energy of an object in a conservative system, given its kinetic and potential energies. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's a Python program that calculates the total mechanical energy of an object in a conservative system:\n\n```python\ndef kinetic_energy(mass, velocity):\n    \"\"\"\n    Calculate the kinetic energy of an object.\n\n    :param mass: float, mass of the object (kg)\n    :param velocity: float, velocity of the object (m/s)\n    :return: float, kinetic energy (Joules)\n    \"\"\"\n    return 0.5 * mass * velocity ** 2\n\n\ndef potential_energy(mass, height, gravity=9.81):\n    \"\"\"\n    Calculate the potential energy of an object.\n\n    :param mass: float, mass of the object (kg)\n    :param height: float, height of the object (m)\n    :param gravity: float, acceleration due to gravity (m/s^2), default is 9.81 (Earth)\n    :return: float, potential energy (Joules)\n    \"\"\"\n    return mass * gravity * height\n\n\ndef total_mechanical_energy(ke, pe):\n    \"\"\"\n    Calculate the total mechanical energy in a conservative system.\n\n    :param ke: float, kinetic energy (Joules)\n    :param pe: float, potential energy (Joules)\n    :return: float, total mechanical energy (Joules)\n    \"\"\"\n    return ke + pe\n\n\nif __name__ == \"__main__\":\n    mass = 10  # kg\n    velocity = 5  # m/s\n    height = 3  # m\n\n    ke = kinetic_energy(mass, velocity)\n    pe = potential_energy(mass, height)\n    tme = total_mechanical_energy(ke, pe)\n\n    print(f\"Kinetic Energy: {ke} J\")\n    print(f\"Potential Energy: {pe} J\")\n    print(f\"Total Mechanical Energy: {tme} J\")\n```\n\nHere's a set of pytest tests for the functions above:\n\n```python\nimport pytest\nfrom your_module import kinetic_energy, potential_energy, total_mechanical_energy\n\ndef test_kinetic_energy():\n    assert kinetic_energy(10, 5) == pytest.approx(125)\n\ndef test_potential_energy():\n    assert potential_energy(10, 3) == pytest.approx(294.3)\n\ndef test_total_mechanical_energy():\n    assert total_mechanical_energy(125, 294.3) == pytest.approx(419.3)\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\n\nMake sure to replace `your_module` with the name of the Python script containing the mechanical energy related functions."}, {"key": "ConceptualPromptV2_4", "prompt": "Generate Python code to perform Principal Component Analysis (PCA) on a given dataset. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python implementation of Principal Component Analysis (PCA) using NumPy and Matplotlib libraries:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generate_example_data():\n    # Generate an example 2D dataset with 200 samples\n    mean_values = [3, 5]\n    covariance_matrix = [[1.5, 1.0], [1.0, 1.5]]\n    data = np.random.multivariate_normal(mean_values, covariance_matrix, size=200)\n    return data\n\ndef normalize_data(data):\n    # Normalize data by subtracting mean and dividing by standard deviation\n    data_normalized = (data - np.mean(data, axis=0)) / np.std(data, axis=0)\n    return data_normalized\n\ndef calculate_covariance_matrix(data):\n    # Calculate the covariance matrix of normalized data\n    covariance_matrix = np.dot(data.T, data) / (data.shape[0] - 1)\n    return covariance_matrix\n\ndef perform_pca(input_data, num_components):\n    # Normalize input data\n    normalized_data = normalize_data(input_data)\n\n    # Calculate covariance matrix\n    covariance_matrix = calculate_covariance_matrix(normalized_data)\n\n    # Calculate eigenvalues and eigenvectors\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n\n    # Sort eigenvectors by decreasing eigenvalues\n    sorted_indices = np.argsort(-eigenvalues)\n    sorted_eigenvectors = eigenvectors[:, sorted_indices]\n\n    # Project data onto the first \"num_components\" principal components\n    transformed_data = np.dot(normalized_data, sorted_eigenvectors[:, :num_components])\n\n    return transformed_data\n\nif __name__ == \"__main__\":\n    example_data = generate_example_data()\n    pca_result = perform_pca(example_data, 2)\n\n    # Plot the original data\n    plt.scatter(example_data[:, 0], example_data[:, 1], label=\"Original Data\")\n\n    # Plot the PCA transformed data\n    plt.scatter(pca_result[:, 0], pca_result[:, 1], label=\"PCA Transformed Data\")\n    plt.legend()\n    plt.show()\n```\n\nHere is a set of pytest tests for the functions above:\n\n```python\nimport pytest\nimport numpy as np\n\ndef test_generate_example_data():\n    example_data = generate_example_data()\n    assert example_data.shape == (200, 2)\n\ndef test_normalize_data():\n    sample_data = np.array([[3, 5], [6, 8], [1, 3], [9, 12]])\n    normalized_data = normalize_data(sample_data)\n    assert np.allclose(np.mean(normalized_data, axis=0), [0, 0])\n    assert np.allclose(np.std(normalized_data, axis=0), [1, 1])\n\ndef test_calculate_covariance_matrix():\n    sample_data = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\n    normalized_data = normalize_data(sample_data)\n    covariance_matrix = calculate_covariance_matrix(normalized_data)\n    assert covariance_matrix.shape == (2, 2)\n\n@pytest.mark.parametrize(\"num_components\", [1, 2, 3])\ndef test_perform_pca(num_components):\n    sample_data = np.array([[1, 0, 1], [2, 1, 0], [3, 2, 2], [4, 3, 4]])\n    pca_result = perform_pca(sample_data, num_components)\n    assert pca_result.shape == (4, num_components)\n```"}, {"key": "ConceptualPromptV2_11", "prompt": "Write Python code to perform hierarchical clustering on a given dataset. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to perform hierarchical clustering on a given dataset using the `scipy` and `matplotlib` libraries. The dataset is assumed to be a 2D numpy array.\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.cluster.hierarchy import dendrogram, linkage\n\n# Sample dataset\ndata = np.array([[0.1, 2.5],\n                 [1.5, 4.1],\n                 [2.0, 5.5],\n                 [3.5, 4.8],\n                 [4.1, 3.0],\n                 [5.5, 0.8],\n                 [6.1, 1.5]])\n\ndef hierarchical_clustering(data, method='single'):\n    \"\"\"\n    Perform hierarchical clustering on the given dataset using the specified method.\n    \n    Parameters:\n    data (numpy.ndarray): The dataset on which to perform clustering.\n    method (str): The clustering method to be used: ('single', 'complete', 'average', 'ward')\n\n    Returns:\n    Z (numpy.ndarray): The hierarchical clustering encoded as a linkage matrix.\n    \"\"\"\n    if method not in ['single', 'complete', 'average', 'ward']:\n        raise ValueError(\"Invalid method. Supported methods are: 'single', 'complete', 'average', 'ward'\")\n    \n    Z = linkage(data, method)\n    return Z\n\ndef plot_dendrogram(Z, labels=None):\n    \"\"\"\n    Plots a dendrogram for the given linkage matrix, Z.\n\n    Parameters:\n    Z (numpy.ndarray): The linkage matrix.\n    labels (list): The labels to use for the leaf nodes.\n\n    Returns:\n    None\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 5))\n    dendrogram(Z, labels=labels, ax=ax)\n    plt.show()\n\n# Hierarchical clustering and visualization\nZ = hierarchical_clustering(data, method='ward')\nplot_dendrogram(Z)\n```\n\nThis code implements a simple hierarchical clustering using the `scipy.cluster.hierarchy` library, and takes a 2D numpy array as input.\n\nNow, here's a set of pytest tests that exercise each of the functions:\n\n```python\nimport numpy as np\nimport pytest\nfrom scipy.spatial.distance import pdist\nfrom scipy.cluster.hierarchy import linkage\n\n@pytest.fixture\ndef sample_data():\n    return np.array([[0.1, 2.5],\n                     [1.5, 4.1],\n                     [2.0, 5.5],\n                     [3.5, 4.8],\n                     [4.1, 3.0],\n                     [5.5, 0.8],\n                     [6.1, 1.5]])\n\ndef test_hierarchical_clustering(sample_data):\n    # Test invalid method argument\n    with pytest.raises(ValueError):\n        hierarchical_clustering(sample_data, method=\"invalid\")\n\n    # Test results with the ward method\n    Z_ward = hierarchical_clustering(sample_data, method=\"ward\")\n    Z_expected = linkage(pdist(sample_data), method=\"ward\")\n    np.testing.assert_almost_equal(Z_ward, Z_expected)\n\n    # Test results with the single method\n    Z_single = hierarchical_clustering(sample_data, method=\"single\")\n    Z_expected = linkage(pdist(sample_data), method=\"single\")\n    np.testing.assert_almost_equal(Z_single, Z_expected)\n\n    # Test results with the complete method\n    Z_complete = hierarchical_clustering(sample_data, method=\"complete\")\n    Z_expected = linkage(pdist(sample_data), method=\"complete\")\n    np.testing.assert_almost_equal(Z_complete, Z_expected)\n\n    # Test results with the average method\n    Z_average = hierarchical_clustering(sample_data, method=\"average\")\n    Z_expected = linkage(pdist(sample_data), method=\"average\")\n    np.testing.assert_almost_equal(Z_average, Z_expected)\n\n# No need to write tests for plot_dendrogram since it's a plotting function and doesn't have any calculations to test\n```\nPlease make sure to have the required libraries (`numpy`, `scipy` and `matplotlib`) installed to run the code."}, {"key": "ConceptualPromptV2_87", "prompt": "Develop a Python function to calculate the price elasticity of demand, given the percentage change in quantity demanded and the percentage change in price. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python function to calculate the price elasticity of demand:\n\n```python\ndef price_elasticity_of_demand(percent_change_quantity_demanded, percent_change_price):\n    \"\"\"\n    Calculate the price elasticity of demand.\n\n    Arguments:\n    percent_change_quantity_demanded -- percentage change in quantity demanded\n    percent_change_price -- percentage change in price\n\n    Returns:\n    Price elasticity of demand\n    \"\"\"\n    if percent_change_price == 0:\n        raise ValueError(\"Percentage change in price cannot be 0\")\n\n    price_elasticity = percent_change_quantity_demanded / percent_change_price\n    return price_elasticity\n```\n\nHere are some pytest tests to exercise the function:\n\n```python\nimport pytest\nfrom your_module import price_elasticity_of_demand\n\ndef test_positive_elasticity():\n    assert price_elasticity_of_demand(-10, 5) == -2\n\ndef test_negative_elasticity():\n    assert price_elasticity_of_demand(5, 5) == 1\n\ndef test_inelastic_demand():\n    assert price_elasticity_of_demand(-5, 20) == -0.25\n\ndef test_division_by_zero():\n    with pytest.raises(ValueError):\n        price_elasticity_of_demand(5, 0)\n```\n\nMake sure to replace `your_module` in the pytest tests with the name of the file where the `price_elasticity_of_demand` function is defined."}, {"key": "ConceptualPromptV2_0", "prompt": "Write Python code to calculate the mean, median, and mode of a list of numbers. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code that calculates the mean, median, and mode of a list of numbers:\n\n```python\nfrom collections import Counter\n\ndef mean(numbers_list):\n    \"\"\"Calculate the mean of the list of numbers.\"\"\"\n    total = sum(numbers_list)\n    count = len(numbers_list)\n    return total / count\n\ndef median(numbers_list):\n    \"\"\"Calculate the median of the list of numbers.\"\"\"\n    sorted_list = sorted(numbers_list)\n    count = len(numbers_list)\n\n    if count % 2 == 0:\n        mid1 = sorted_list[(count // 2) - 1]\n        mid2 = sorted_list[count // 2]\n        return (mid1 + mid2) / 2\n    else:\n        return sorted_list[count // 2]\n\ndef mode(numbers_list):\n    \"\"\"Calculate the mode of the list of numbers.\"\"\"\n    num_frequency = Counter(numbers_list)\n    max_frequency = max(num_frequency.values())\n    return [n for n, freq in num_frequency.items() if freq == max_frequency]\n\n# Example usage:\nnumbers_list = [4, 2, 7, 4, 3, 8, 9, 4, 5]\n\nmean_value = mean(numbers_list)\nmedian_value = median(numbers_list)\nmode_values = mode(numbers_list)\n\nprint(\"Mean:\", mean_value)\nprint(\"Median:\", median_value)\nprint(\"Mode:\", mode_values)\n```\n\nAnd here's a set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom mean_median_mode import mean, median, mode\n\ndef test_mean():\n    assert mean([10, 20, 30, 40, 50]) == 30\n    assert mean([1, 2, 3, 4, 5, 6, 7]) == 4\n    assert mean([5, 6, 7, 8, 5, 6, 5]) == 6\n\ndef test_median():\n    assert median([10, 20, 30, 40, 50]) == 30\n    assert median([1, 2, 3, 4, 5, 6, 7]) == 4\n    assert median([5, 6, 7, 8, 5, 6, 5]) == 6\n    assert median([1, 2, 3, 4, 5, 6]) == 3.5\n\ndef test_mode():\n    assert mode([10, 20, 30, 40, 50]) == [10, 20, 30, 40, 50]\n    assert mode([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7]\n    assert mode([10, 20, 30, 40, 50, 30]) == [30]\n    assert mode([5, 6, 7, 8, 5, 6, 5]) == [5]\n\nif __name__ == \"__main__\":\n    pytest.main()\n```\nPlease note that for the pytest tests, you will need to save the mean, median, and mode functions in a separate file named `mean_median_mode.py`."}, {"key": "ConceptualPromptV2_94", "prompt": "Write a Python program to calculate the consumer price index (CPI), given the prices of a basket of goods in the base year and the current year. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is a Python program to calculate the consumer price index (CPI):\n\n```python\ndef calculate_cpi(base_year_prices, current_year_prices):\n    \"\"\"\n    Calculate the Consumer Price Index (CPI) given the base year and current year prices.\n    :param base_year_prices: A dictionary of items with their corresponding prices in the base year.\n    :param current_year_prices: A dictionary of items with their corresponding prices in the current year.\n    :return: Consumer Price Index (CPI) as a percentage.\n    \"\"\"\n\n    base_year_index = sum(base_year_prices.values())\n    current_year_index = sum(current_year_prices.values())\n    cpi = (current_year_index / base_year_index) * 100\n    return cpi\n\n\nif __name__ == \"__main__\":\n    base_year_prices = {\n        \"apple\": 1.0,\n        \"banana\": 0.5,\n        \"milk\": 2.5,\n        \"bread\": 2.0\n    }\n    current_year_prices = {\n        \"apple\": 1.2,\n        \"banana\": 0.6,\n        \"milk\": 3.0,\n        \"bread\": 2.2\n    }\n\n    cpi = calculate_cpi(base_year_prices, current_year_prices)\n    print(\"The Consumer Price Index (CPI) is {:.2f}%.\".format(cpi))\n```\nHere are the pytest tests to exercise each of the functions:\n\n```python\nimport pytest\nfrom cpi_calculator import calculate_cpi\n\n\ndef test_calculate_cpi():\n    base_year_prices = {\n        \"apple\": 1.0,\n        \"banana\": 0.5,\n        \"milk\": 2.5,\n        \"bread\": 2.0\n    }\n    current_year_prices_1 = {\n        \"apple\": 1.2,\n        \"banana\": 0.6,\n        \"milk\": 3.0,\n        \"bread\": 2.2\n    }\n    current_year_prices_2 = {\n        \"apple\": 1.4,\n        \"banana\": 0.7,\n        \"milk\": 3.5,\n        \"bread\": 3.0\n    }\n    \n    result_1 = calculate_cpi(base_year_prices, current_year_prices_1)\n    result_2 = calculate_cpi(base_year_prices, current_year_prices_2)\n\n    assert round(result_1, 2) == 116.00\n    assert round(result_2, 2) == 134.00\n```\n\nDon't forget to save the Python program in a file named `cpi_calculator.py` so that the pytest can import the `calculate_cpi` function properly."}, {"key": "ConceptualPromptV2_19", "prompt": "Generate Python code to perform the Kolmogorov-Smirnov test to compare two probability distributions. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here's the Python code to perform the Kolmogorov-Smirnov test to compare two probability distributions using SciPy:\n\n```python\nimport numpy as np\nfrom scipy.stats import ks_2samp\n\ndef generate_random_samples(dist_func, size=100, *args, **kwargs):\n    \"\"\"\n    Generate random samples from the given distribution function.\n    \n    :param dist_func: Distribution function to generate samples from\n    :param size: Number of samples to generate (default is 100)\n    :param *args: Additional positional arguments for the distribution function\n    :param **kwargs: Additional keyword arguments for the distribution function\n    :return: NumPy array of generated samples\n    \"\"\"\n    samples = dist_func.rvs(size=size, *args, **kwargs)\n    return samples\n\ndef perform_ks_test(sample1, sample2):\n    \"\"\"\n    Perform the Kolmogorov-Smirnov test on two sets of samples.\n    \n    :param sample1: First set of samples\n    :param sample2: Second set of samples\n    :return: KS statistic and p-value\n    \"\"\"\n    ks_statistic, p_value = ks_2samp(sample1, sample2)\n    return ks_statistic, p_value\n\nif __name__ == \"__main__\":\n    from scipy.stats import norm, expon\n\n    np.random.seed(42)\n\n    # Generate random samples from normal and exponential distributions\n    normal_samples1 = generate_random_samples(norm, size=100, loc=0, scale=1)\n    normal_samples2 = generate_random_samples(norm, size=100, loc=0, scale=1)\n    exp_samples = generate_random_samples(expon, size=100, scale=1)\n    \n    # Perform KS test on various sample combinations\n    ks_stat_same, p_value_same = perform_ks_test(normal_samples1, normal_samples2)\n    ks_stat_diff, p_value_diff = perform_ks_test(normal_samples1, exp_samples)\n    \n    print(\"KS test result for same distributions:\")\n    print(f\"KS statistic: {ks_stat_same}, p-value: {p_value_same}\")\n\n    print(\"KS test result for different distributions:\")\n    print(f\"KS statistic: {ks_stat_diff}, p-value: {p_value_diff}\")\n```\n\nNow here's a set of pytest tests for the functions:\n\n```python\nimport pytest\nfrom scipy.stats import norm, expon\n\ndef test_generate_random_samples():\n    np.random.seed(42)\n    samples = generate_random_samples(norm, size=50, loc=0, scale=1)\n    assert len(samples) == 50, \"Number of samples should match the specified size\"\n    assert np.mean(samples) <= 0.1, \"Mean value of generated samples should be close to the specified mean\"\n\ndef test_perform_ks_test():\n    np.random.seed(42)\n    normal_samples1 = generate_random_samples(norm, size=100, loc=0, scale=1)\n    normal_samples2 = generate_random_samples(norm, size=100, loc=0, scale=1)\n    exp_samples = generate_random_samples(expon, size=100, scale=1)\n\n    ks_stat_same, p_value_same = perform_ks_test(normal_samples1, normal_samples2)\n    ks_stat_diff, p_value_diff = perform_ks_test(normal_samples1, exp_samples)\n\n    assert ks_stat_same < ks_stat_diff, \"KS statistic for same distributions should be smaller\"\n    assert p_value_same > p_value_diff, \"p-value for same distributions should be larger\"\n    assert p_value_same > 0.05, \"p-value for same distributions should be larger than 0.05\"\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n```"}, {"key": "ConceptualPromptV2_86", "prompt": "Write a Python program to compute the Gini coefficient of income inequality, given a list of income values. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python program to compute the Gini coefficient of income inequality:\n\n```python\ndef gini_coefficient(income_list):\n    \"\"\"\n    Calculate the Gini coefficient based on the input list of incomes.\n    :param income_list: list of incomes (floating point numbers)\n    :return: Gini coefficient (floating pointNumber)\n    \"\"\"\n    n = len(income_list)\n    sorted_incomes = sorted(income_list)\n    sum_of_absolute_differences = 0\n\n    for i in range(n):\n        sum_of_absolute_differences += (i - (n - 1) / 2) * sorted_incomes[i]\n\n    mean_income = sum(income_list) / n\n    gini = (sum_of_absolute_differences / mean_income) / n\n\n    return gini\n\n\nif __name__ == \"__main__\":\n    incomes = [50000, 100000, 30000, 60000, 45000]\n    print(\"Gini Coefficient:\", gini_coefficient(incomes))\n```\n\nHere is the set of pytest tests that exercise each of the functions:\n\n```python\nimport pytest\nfrom gini import gini_coefficient\n\ndef test_gini_positive_numbers():\n    assert pytest.approx(gini_coefficient([40000, 80000, 20000, 100000, 60000])) == 0.24489796\n\ndef test_gini_zeroes():\n    assert pytest.approx(gini_coefficient([0, 0, 0, 0])) == 0.0\n\ndef test_gini_single_value():\n    assert pytest.approx(gini_coefficient([55000])) == 0.0\n\ndef test_gini_negative_values():\n    with pytest.raises(ValueError):\n        gini_coefficient([-10000, 30000, 60000, 20000])\n```\n\nPlease note that to use the pytest package, you'll need to install it first by running `pip install pytest`. Additionally, you should save the Gini coefficient calculation script in a separate file named `gini.py`."}, {"key": "ConceptualPromptV2_12", "prompt": "Create Python code to implement a Naive Bayes classifier for text classification. Please embed the code within an explicit code block, surrounded by triple-backtick markers. Generate realistic values for any examples, and do not use input() commands. Create code that is modular and well-commented.  Then, generate a set of pytest tests that exercise each of the functions, embedded in a separate code block.", "answer": "Here is the Python code implementing a simple Naive Bayes classifier for text classification:\n\n```python\nimport numpy as np\nfrom collections import defaultdict\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\nclass NaiveBayesClassifier:\n    def __init__(self):\n        self.word_counts = defaultdict(int)\n        self.class_counts = defaultdict(int)\n\n    def _tokenize(self, X):\n        vectorizer = CountVectorizer()\n        return vectorizer.fit_transform(X)\n\n    def _calculate_prior(self, y):\n        total_classes = len(y)\n        for label in y:\n            self.class_counts[label] += 1\n\n        for label, count in self.class_counts.items():\n            self.class_counts[label] = count / total_classes\n\n    def _calculate_word_probabilities(self, X, y):\n        for label in np.unique(y):\n            word_count = X[y == label].sum(axis=0) + 1\n            total_word_count = word_count.sum()\n            self.word_counts[label] = word_count / total_word_count\n\n    def fit(self, X_train, y_train):\n        X_train_tokenized = self._tokenize(X_train)\n        self._calculate_prior(y_train)\n        self._calculate_word_probabilities(X_train_tokenized, y_train)\n\n    def predict(self, X_test):\n        X_test_tokenized = self._tokenize(X_test)\n        predictions = []\n\n        for text in X_test_tokenized:\n            class_scores = {}\n            for label, word_probs in self.word_counts.items():\n                class_scores[label] = self.class_counts[label] * np.prod(np.power(word_probs, text))\n                \n            predicted_class = max(class_scores, key=class_scores.get)\n            predictions.append(predicted_class)\n\n        return np.array(predictions)\n\nsamples = [\n    \"The movie was excellent\",\n    \"I did not like the movie\",\n    \"Great movie, I loved it\",\n    \"The film was boring\",\n    \"Fantastic film, I would watch it again\",\n    \"I would not recommend watching the film\"\n]\n\nlabels = np.array([1, 0, 1, 0, 1, 0])\n\nX_train, X_test, y_train, y_test = train_test_split(samples, labels, test_size=0.33, random_state=42)\n\nclassifier = NaiveBayesClassifier()\nclassifier.fit(X_train, y_train)\npredictions = classifier.predict(X_test)\nprint(f\"Accuracy: {accuracy_score(y_test, predictions)}\")\n```\n\nHere are the pytest tests for the Naive Bayes classifier:\n\n```python\nimport pytest\nfrom nb_classifier import NaiveBayesClassifier\nimport numpy as np\n\n@pytest.fixture\ndef classifier():\n    return NaiveBayesClassifier()\n\ndef test_tokenize(classifier):\n    tokenized_sample = classifier._tokenize([\"I love movies.\n    \"])\n    assert tokenized_sample.shape[0] == 1, \"Tokenize should have 1 row\"\n\ndef test_calculate_prior(classifier):\n    labels = np.array([1, 0, 1, 0, 1, 0])\n    classifier._calculate_prior(labels)\n    assert set(classifier.class_counts.keys()) == {0, 1}, \"Class_counts keys should contain both 0 and 1\"\n    assert abs(classifier.class_counts[0] - 0.5) < 1e-6, \"Class_count value for label 0 should be close to 0.5\"\n    assert abs(classifier.class_counts[1] - 0.5) < 1e-6, \"Class_count value for label 1 should be close to 0.5\"\n\ndef test_fit(classifier):\n    samples = [\"The movie was excellent\", \"I did not like the movie\", \"Great movie, I loved it\"]\n    labels = np.array([1, 0, 1])\n    classifier.fit(samples, labels)\n    assert set(classifier.word_counts.keys()) == {0, 1}, \"Word_counts keys should contain both 0 and 1\"\n\ndef test_predict(classifier):\n    samples = [\"The movie was excellent\", \"I did not like the movie\", \"Great movie, I loved it\"]\n    labels = np.array([1, 0, 1])\n    classifier.fit(samples, labels)\n    predictions = classifier.predict([\"The movie was boring\"])\n    assert isinstance(predictions, np.ndarray), \"Predictions should be a numpy array\"\n    assert predictions.shape[0] == 1, \"Predictions should have 1 element\"\n    assert predictions[0] == 0, \"The predicted class for 'The movie was boring' should be 0\"\n```\n\nSave the classifier code in a file named `nb_classifier.py` and the tests in a file named `test_nb_classifier.py` in the same directory. Run the tests using `pytest`."}]